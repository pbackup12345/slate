{"version":3,"file":"index.js","sources":["../../../node_modules/@babel/runtime/helpers/classCallCheck.js","../src/utils/state.ts","../../../node_modules/@babel/runtime/helpers/createClass.js","../src/classes/path-ref.ts","../src/classes/point-ref.ts","../src/classes/range-ref.ts","../src/interfaces/element.ts","../src/interfaces/location.ts","../src/interfaces/mark.ts","../../../node_modules/@babel/runtime/helpers/arrayWithHoles.js","../../../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../../../node_modules/@babel/runtime/helpers/nonIterableRest.js","../../../node_modules/@babel/runtime/helpers/slicedToArray.js","../../../node_modules/regenerator-runtime/runtime.js","../../../node_modules/@babel/runtime/regenerator/index.js","../src/interfaces/node.ts","../../../node_modules/@babel/runtime/helpers/defineProperty.js","../src/interfaces/operation.ts","../src/interfaces/path.ts","../src/interfaces/point.ts","../../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","../../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js","../src/interfaces/range.ts","../src/interfaces/text.ts","../../../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","../../../node_modules/@babel/runtime/helpers/iterableToArray.js","../../../node_modules/@babel/runtime/helpers/nonIterableSpread.js","../../../node_modules/@babel/runtime/helpers/toConsumableArray.js","../src/interfaces/value.ts","../src/classes/commands/annotation.ts","../src/classes/commands/text.ts","../src/classes/commands/node.ts","../src/classes/commands/mark.ts","../src/classes/commands/selection.ts","../src/classes/commands/general.ts","../src/classes/queries/element.ts","../src/classes/queries/general.ts","../src/utils/strings.ts","../src/classes/queries/location.ts","../src/classes/queries/node.ts","../src/classes/queries/range.ts","../src/classes/editor.ts"],"sourcesContent":["function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","import { Editor, Path, PathRef, PointRef, RangeRef } from '..'\r\n\r\n/**\r\n * Weak maps to keep track of instance-level editor state.\r\n */\r\n\r\nexport const DIRTY_PATHS: WeakMap<Editor, Path[]> = new WeakMap()\r\nexport const NORMALIZING: WeakMap<Editor, boolean> = new WeakMap()\r\nexport const FLUSHING: WeakMap<Editor, boolean> = new WeakMap()\r\nexport const PATH_REFS: WeakMap<Editor, Set<PathRef>> = new WeakMap()\r\nexport const POINT_REFS: WeakMap<Editor, Set<PointRef>> = new WeakMap()\r\nexport const RANGE_REFS: WeakMap<Editor, Set<RangeRef>> = new WeakMap()\r\n","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","import { Operation, Path, Editor } from '..'\r\nimport { PATH_REFS } from '../utils/state'\r\n\r\n/**\r\n * `PathRef` objects keep a specific path in a document synced over time as new\r\n * operations are applied to the editor. You can access their `current` property\r\n * at any time for the up-to-date path value.\r\n */\r\n\r\nexport class PathRef {\r\n  current: Path | null\r\n  private affinity: 'forward' | 'backward' | null\r\n  private editor: Editor\r\n\r\n  constructor(props: {\r\n    path: Path | null\r\n    affinity: 'forward' | 'backward' | null\r\n    editor: Editor\r\n  }) {\r\n    const { path, affinity, editor } = props\r\n    this.current = path\r\n    this.affinity = affinity\r\n    this.editor = editor\r\n    const pathRefs = PATH_REFS.get(editor)!\r\n    pathRefs.add(this)\r\n  }\r\n\r\n  /**\r\n   * Transform the path ref's current value by an operation.\r\n   */\r\n\r\n  transform(op: Operation): void {\r\n    const { current, affinity } = this\r\n\r\n    if (current == null) {\r\n      return\r\n    }\r\n\r\n    const path = Path.transform(current, op, { affinity })\r\n    this.current = path\r\n\r\n    if (path == null) {\r\n      this.unref()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unreference the ref, allowing the editor to stop updating its value.\r\n   */\r\n\r\n  unref(): Path | null {\r\n    const { current, editor } = this\r\n    const pathRefs = PATH_REFS.get(editor)!\r\n    pathRefs.delete(this)\r\n    this.current = null\r\n    return current\r\n  }\r\n}\r\n","import { Operation, Point, Editor } from '..'\r\nimport { POINT_REFS } from '../utils/state'\r\n\r\n/**\r\n * `PointRef` objects keep a specific point in a document synced over time as new\r\n * operations are applied to the editor. You can access their `current` property\r\n * at any time for the up-to-date point value.\r\n */\r\n\r\nexport class PointRef {\r\n  current: Point | null\r\n  private affinity: 'forward' | 'backward' | null\r\n  private editor: Editor\r\n\r\n  constructor(props: {\r\n    point: Point | null\r\n    affinity: 'forward' | 'backward' | null\r\n    editor: Editor\r\n  }) {\r\n    const { point, affinity, editor } = props\r\n    this.current = point\r\n    this.affinity = affinity\r\n    this.editor = editor\r\n    const pointRefs = POINT_REFS.get(editor)!\r\n    pointRefs.add(this)\r\n  }\r\n\r\n  /**\r\n   * Transform the point ref's current value by an operation.\r\n   */\r\n\r\n  transform(op: Operation): void {\r\n    const { current, affinity } = this\r\n\r\n    if (current == null) {\r\n      return\r\n    }\r\n\r\n    const point = Point.transform(current, op, { affinity })\r\n    this.current = point\r\n\r\n    if (point == null) {\r\n      this.unref()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unreference the ref, allowing the editor to stop updating its value.\r\n   */\r\n\r\n  unref(): Point | null {\r\n    const { current, editor } = this\r\n    const pointRefs = POINT_REFS.get(editor)!\r\n    pointRefs.delete(this)\r\n    this.current = null\r\n    return current\r\n  }\r\n}\r\n","import { Operation, Range, Editor } from '..'\r\nimport { RANGE_REFS } from '../utils/state'\r\n\r\n/**\r\n * `RangeRef` objects keep a specific range in a document synced over time as new\r\n * operations are applied to the editor. You can access their `current` property\r\n * at any time for the up-to-date range value.\r\n */\r\n\r\nexport class RangeRef {\r\n  current: Range | null\r\n  private affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\r\n  private editor: Editor\r\n\r\n  constructor(props: {\r\n    range: Range | null\r\n    affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\r\n    editor: Editor\r\n  }) {\r\n    const { range, affinity, editor } = props\r\n    this.current = range\r\n    this.affinity = affinity\r\n    this.editor = editor\r\n    const rangeRefs = RANGE_REFS.get(editor)!\r\n    rangeRefs.add(this)\r\n  }\r\n\r\n  /**\r\n   * Transform the range ref's current value by an operation.\r\n   */\r\n\r\n  transform(op: Operation): void {\r\n    const { current, affinity } = this\r\n\r\n    if (current == null) {\r\n      return\r\n    }\r\n\r\n    const range = Range.transform(current, op, { affinity })\r\n    this.current = range\r\n\r\n    if (range == null) {\r\n      this.unref()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unreference the ref, allowing the editor to stop updating its value.\r\n   */\r\n\r\n  unref(): Range | null {\r\n    const { current, editor } = this\r\n    const rangeRefs = RANGE_REFS.get(editor)!\r\n    rangeRefs.delete(this)\r\n    this.current = null\r\n    return current\r\n  }\r\n}\r\n","import isPlainObject from 'is-plain-object'\r\nimport { Node, Path, Value } from '..'\r\n\r\n/**\r\n * `Element` objects are a type of node in a Slate document that contain other\r\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\r\n * depending on the Slate editor's schema.\r\n */\r\n\r\ninterface Element {\r\n  children: Node[]\r\n  [key: string]: any\r\n}\r\n\r\n/**\r\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\r\n * found inside a root node.\r\n */\r\n\r\ntype ElementEntry = [Element, Path]\r\n\r\nnamespace Element {\r\n  /**\r\n   * Check if a value implements the `Element` interface.\r\n   */\r\n\r\n  export const isElement = (value: any): value is Element => {\r\n    return (\r\n      isPlainObject(value) &&\r\n      Node.isNodeList(value.children) &&\r\n      !Value.isValue(value)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */\r\n\r\n  export const isElementList = (value: any): value is Element[] => {\r\n    return (\r\n      Array.isArray(value) &&\r\n      (value.length === 0 || Element.isElement(value[0]))\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: the is for checking custom properties, and it does not ensure that\r\n   * any children in the `children` property are equal.\r\n   */\r\n\r\n  export const matches = (\r\n    element: Element,\r\n    props: Partial<Element>\r\n  ): boolean => {\r\n    for (const key in props) {\r\n      if (key === 'children') {\r\n        continue\r\n      }\r\n\r\n      if (element[key] !== props[key]) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\nexport { Element, ElementEntry }\r\n","import { Path, Point, Range } from '..'\r\n\r\n/**\r\n * The `Location` interface is a union of the ways to refer to a specific\r\n * location in a Slate document: paths, points or ranges.\r\n *\r\n * Methods will often accept a `Location` instead of requiring only a `Path`,\r\n * `Point` or `Range`. This eliminates the need for developers to manage\r\n * converting between the different interfaces in their own code base.\r\n */\r\n\r\ntype Location = Path | Point | Range\r\n\r\nnamespace Location {\r\n  /**\r\n   * Check if a value implements the `Location` interface.\r\n   */\r\n\r\n  export const isLocation = (value: any): value is Location => {\r\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value)\r\n  }\r\n}\r\n\r\ntype Span = [Path, Path]\r\n\r\nnamespace Span {\r\n  /**\r\n   * Check if a value implements the `Span` interface.\r\n   */\r\n\r\n  export const isSpan = (value: any): value is Span => {\r\n    return (\r\n      Array.isArray(value) && value.length === 2 && value.every(Path.isPath)\r\n    )\r\n  }\r\n}\r\n\r\nexport { Location, Span }\r\n","import isPlainObject from 'is-plain-object'\r\nimport { Path, Text } from '..'\r\n\r\n/**\r\n * `Mark` objects represent formatting that is applied to text in a Slate\r\n * document. They appear in leaf text nodes in the document, as well as in\r\n * annotations on the root value object.\r\n */\r\n\r\nexport interface Mark {\r\n  [key: string]: any\r\n}\r\n\r\nexport namespace Mark {\r\n  /**\r\n   * Check if a mark exists in a set of marks.\r\n   */\r\n\r\n  export const exists = (mark: Mark, marks: Mark[]): boolean => {\r\n    return !!marks.find(f => Mark.matches(f, mark))\r\n  }\r\n\r\n  /**\r\n   * Check if a value implements the `Mark` interface.\r\n   */\r\n\r\n  export const isMark = (value: any): value is Mark => {\r\n    return isPlainObject(value)\r\n  }\r\n\r\n  /**\r\n   * Check if a value is an array of `Mark` objects.\r\n   */\r\n\r\n  export const isMarkSet = (value: any): value is Mark[] => {\r\n    return Array.isArray(value) && (value.length === 0 || Mark.isMark(value[0]))\r\n  }\r\n\r\n  /**\r\n   * Check if a mark matches set of properties.\r\n   */\r\n\r\n  export const matches = (mark: Mark, props: Partial<Mark>): boolean => {\r\n    for (const key in props) {\r\n      if (mark[key] !== props[key]) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\n/**\r\n * `MarkEntry` tuples are returned when iterating through the marks in a text\r\n * node. They include the index of the mark in the text node's marks array, as\r\n * well as the text node and its path in the root node.\r\n */\r\n\r\nexport type MarkEntry = [Mark, number, Text, Path]\r\n\r\n/**\r\n * `MarkMatch` values are used as shorthands for matching mark objects.\r\n */\r\n\r\nexport type MarkMatch = Partial<Mark> | ((entry: MarkEntry) => boolean)\r\n","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","module.exports = require(\"regenerator-runtime\");\n","import { produce } from 'immer'\r\nimport {\r\n  Element,\r\n  ElementEntry,\r\n  MarkEntry,\r\n  Path,\r\n  Range,\r\n  Text,\r\n  TextEntry,\r\n  Value,\r\n} from '..'\r\n\r\n/**\r\n * The `Node` union type represents all of the different types of nodes that\r\n * occur in a Slate document tree.\r\n */\r\n\r\nexport type Node = Value | Element | Text\r\n\r\nexport namespace Node {\r\n  export const matches = (node: Node, props: Partial<Node>): boolean => {\r\n    return (\r\n      (Value.isValue(node) && Value.matches(node, props)) ||\r\n      (Element.isElement(node) && Element.matches(node, props)) ||\r\n      (Text.isText(node) && Text.matches(node, props))\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */\r\n\r\n  export const ancestor = (root: Node, path: Path): Ancestor => {\r\n    const node = Node.get(root, path)\r\n\r\n    if (Text.isText(node)) {\r\n      throw new Error(\r\n        `Cannot get the ancestor node at path [${path}] because it refers to a text node instead: ${node}`\r\n      )\r\n    }\r\n\r\n    return node\r\n  }\r\n\r\n  /**\r\n   * Return an iterable of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is bottom-up, from lowest to highest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go top-down.\r\n   */\r\n\r\n  export function* ancestors(\r\n    root: Node,\r\n    path: Path,\r\n    options: {\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Iterable<AncestorEntry> {\r\n    for (const p of Path.ancestors(path, options)) {\r\n      const n = Node.ancestor(root, p)\r\n      const entry: AncestorEntry = [n, p]\r\n      yield entry\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the child of a node at a specific index.\r\n   */\r\n\r\n  export const child = (root: Node, index: number): Descendant => {\r\n    if (Text.isText(root)) {\r\n      throw new Error(\r\n        `Cannot get the child of a text node: ${JSON.stringify(root)}`\r\n      )\r\n    }\r\n\r\n    const c = root.children[index] as Descendant\r\n\r\n    if (c == null) {\r\n      throw new Error(\r\n        `Cannot get child at index \\`${index}\\` in node: ${JSON.stringify(\r\n          root\r\n        )}`\r\n      )\r\n    }\r\n\r\n    return c\r\n  }\r\n\r\n  /**\r\n   * Find the closest matching node entry starting from a specific path.\r\n   */\r\n\r\n  export const closest = (\r\n    root: Node,\r\n    path: Path,\r\n    predicate: (entry: NodeEntry) => boolean\r\n  ): NodeEntry | undefined => {\r\n    for (const entry of Node.levels(root, path, { reverse: true })) {\r\n      if (predicate(entry)) {\r\n        return entry\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */\r\n\r\n  export const common = (root: Node, path: Path, another: Path): NodeEntry => {\r\n    const p = Path.common(path, another)\r\n    const n = Node.get(root, p)\r\n    return [n, p]\r\n  }\r\n\r\n  /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */\r\n\r\n  export const descendant = (root: Node, path: Path): Descendant => {\r\n    const node = Node.get(root, path)\r\n\r\n    if (Value.isValue(node)) {\r\n      throw new Error(\r\n        `Cannot get the descendant node at path [${path}] because it refers to a value node instead: ${node}`\r\n      )\r\n    }\r\n\r\n    return node\r\n  }\r\n\r\n  /**\r\n   * Return an iterable of all the descendant node entries inside a root node.\r\n   */\r\n\r\n  export function* descendants(\r\n    root: Node,\r\n    options: {\r\n      from?: Path\r\n      to?: Path\r\n      reverse?: boolean\r\n      pass?: (node: NodeEntry) => boolean\r\n    } = {}\r\n  ): Iterable<DescendantEntry> {\r\n    for (const [node, path] of Node.nodes(root, options)) {\r\n      if (path.length !== 0) {\r\n        // NOTE: we have to coerce here because checking the path's length does\r\n        // guarantee that `node` is not a `Value`, but TypeScript doesn't know.\r\n        yield [node, path] as DescendantEntry\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return an iterable of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */\r\n\r\n  export function* elements(\r\n    root: Node,\r\n    options: {\r\n      from?: Path\r\n      to?: Path\r\n      reverse?: boolean\r\n      pass?: (node: NodeEntry) => boolean\r\n    } = {}\r\n  ): Iterable<ElementEntry> {\r\n    for (const [node, path] of Node.nodes(root, options)) {\r\n      if (Element.isElement(node)) {\r\n        yield [node, path]\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the first node entry in a root node from a path.\r\n   */\r\n\r\n  export const first = (root: Node, path: Path): NodeEntry => {\r\n    const p = path.slice()\r\n    let n = Node.get(root, p)\r\n\r\n    while (n) {\r\n      if (Text.isText(n) || n.children.length === 0) {\r\n        break\r\n      } else {\r\n        n = n.children[0]\r\n        p.push(0)\r\n      }\r\n    }\r\n\r\n    return [n, p]\r\n  }\r\n\r\n  /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */\r\n\r\n  export const fragment = (root: Node, range: Range): Descendant[] => {\r\n    if (Text.isText(root)) {\r\n      throw new Error(\r\n        `Cannot get a fragment starting from a root text node: ${JSON.stringify(\r\n          root\r\n        )}`\r\n      )\r\n    }\r\n\r\n    const newRoot = produce(root, r => {\r\n      const [start, end] = Range.edges(range)\r\n      const iterable = Node.nodes(r, {\r\n        reverse: true,\r\n        pass: ([, path]) => !Range.includes(range, path),\r\n      })\r\n\r\n      for (const [, path] of iterable) {\r\n        if (!Range.includes(range, path)) {\r\n          const parent = Node.parent(r, path)\r\n          const index = path[path.length - 1]\r\n          parent.children.splice(index, 1)\r\n        }\r\n\r\n        if (Path.equals(path, end.path)) {\r\n          const leaf = Node.leaf(r, path)\r\n          leaf.text = leaf.text.slice(0, end.offset)\r\n        }\r\n\r\n        if (Path.equals(path, start.path)) {\r\n          const leaf = Node.leaf(r, path)\r\n          leaf.text = leaf.text.slice(start.offset)\r\n        }\r\n      }\r\n\r\n      delete r.annotations\r\n      delete r.selection\r\n    })\r\n\r\n    return newRoot.children\r\n  }\r\n\r\n  /**\r\n   * Find the furthest matching node entry starting from a specific path.\r\n   */\r\n\r\n  export const furthest = (\r\n    root: Node,\r\n    path: Path,\r\n    predicate: (entry: NodeEntry) => boolean\r\n  ): NodeEntry | undefined => {\r\n    for (const entry of Node.levels(root, path)) {\r\n      if (predicate(entry)) {\r\n        return entry\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */\r\n\r\n  export const get = (root: Node, path: Path): Node => {\r\n    let node = root\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n      const p = path[i]\r\n\r\n      if (Text.isText(node) || !node.children[p]) {\r\n        throw new Error(\r\n          `Cannot find a descendant at path [${path}] in node: ${JSON.stringify(\r\n            root\r\n          )}`\r\n        )\r\n      }\r\n\r\n      node = node.children[p]\r\n    }\r\n\r\n    return node\r\n  }\r\n\r\n  /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */\r\n\r\n  export const has = (root: Node, path: Path): boolean => {\r\n    let node = root\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n      const p = path[i]\r\n\r\n      if (Text.isText(node) || !node.children[p]) {\r\n        return false\r\n      }\r\n\r\n      node = node.children[p]\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Check if a value implements the `Node` interface.\r\n   */\r\n\r\n  export const isNode = (value: any): value is Node => {\r\n    return (\r\n      Text.isText(value) || Element.isElement(value) || Value.isValue(value)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */\r\n\r\n  export const isNodeList = (value: any): value is Node[] => {\r\n    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]))\r\n  }\r\n\r\n  /**\r\n   * Get the lash node entry in a root node from a path.\r\n   */\r\n\r\n  export const last = (root: Node, path: Path): NodeEntry => {\r\n    const p = path.slice()\r\n    let n = Node.get(root, p)\r\n\r\n    while (n) {\r\n      if (Text.isText(n) || n.children.length === 0) {\r\n        break\r\n      } else {\r\n        const i = n.children.length - 1\r\n        n = n.children[i]\r\n        p.push(i)\r\n      }\r\n    }\r\n\r\n    return [n, p]\r\n  }\r\n\r\n  /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */\r\n\r\n  export const leaf = (root: Node, path: Path): Text => {\r\n    const node = Node.get(root, path)\r\n\r\n    if (!Text.isText(node)) {\r\n      throw new Error(\r\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${node}`\r\n      )\r\n    }\r\n\r\n    return node\r\n  }\r\n\r\n  /**\r\n   * Return an iterable of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from lowest to highest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */\r\n\r\n  export function* levels(\r\n    root: Node,\r\n    path: Path,\r\n    options: {\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Iterable<NodeEntry> {\r\n    for (const p of Path.levels(path, options)) {\r\n      const n = Node.get(root, p)\r\n      yield [n, p]\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return an iterable of all the marks in all of the text nodes in a root node.\r\n   */\r\n\r\n  export function* marks(\r\n    root: Node,\r\n    options: {\r\n      from?: Path\r\n      to?: Path\r\n      reverse?: boolean\r\n      pass?: (node: NodeEntry) => boolean\r\n    } = {}\r\n  ): Iterable<MarkEntry> {\r\n    for (const [node, path] of Node.texts(root, options)) {\r\n      for (let i = 0; i < node.marks.length; i++) {\r\n        const mark = node.marks[i]\r\n        yield [mark, i, node, path]\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return an iterable of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */\r\n\r\n  export function* nodes(\r\n    root: Node,\r\n    options: {\r\n      from?: Path\r\n      to?: Path\r\n      reverse?: boolean\r\n      pass?: (entry: NodeEntry) => boolean\r\n    } = {}\r\n  ): Iterable<NodeEntry> {\r\n    const { pass, reverse = false } = options\r\n    const { from = [], to } = options\r\n    const visited = new Set()\r\n    let p: Path = []\r\n    let n = root\r\n\r\n    while (true) {\r\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\r\n        break\r\n      }\r\n\r\n      if (!visited.has(n)) {\r\n        yield [n, p]\r\n      }\r\n\r\n      // If we're allowed to go downward and we haven't decsended yet, do.\r\n      if (\r\n        !visited.has(n) &&\r\n        !Text.isText(n) &&\r\n        n.children.length !== 0 &&\r\n        (pass == null || pass([n, p]) === false)\r\n      ) {\r\n        visited.add(n)\r\n        let nextIndex = reverse ? n.children.length - 1 : 0\r\n\r\n        if (Path.isAncestor(p, from)) {\r\n          nextIndex = from[p.length]\r\n        }\r\n\r\n        p = p.concat(nextIndex)\r\n        n = Node.get(root, p)\r\n        continue\r\n      }\r\n\r\n      // If we're at the root and we can't go down, we're done.\r\n      if (p.length === 0) {\r\n        break\r\n      }\r\n\r\n      // If we're going forward...\r\n      if (!reverse) {\r\n        const newPath = Path.next(p)\r\n\r\n        if (Node.has(root, newPath)) {\r\n          p = newPath\r\n          n = Node.get(root, p)\r\n          continue\r\n        }\r\n      }\r\n\r\n      // If we're going backward...\r\n      if (reverse && p[p.length - 1] !== 0) {\r\n        const newPath = Path.previous(p)\r\n        p = newPath\r\n        n = Node.get(root, p)\r\n        continue\r\n      }\r\n\r\n      // Otherwise we're going upward...\r\n      p = Path.parent(p)\r\n      n = Node.get(root, p)\r\n      visited.add(n)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the parent of a node at a specific path.\r\n   */\r\n\r\n  export const parent = (root: Node, path: Path): Ancestor => {\r\n    const parentPath = Path.parent(path)\r\n    const p = Node.get(root, parentPath)\r\n\r\n    if (Text.isText(p)) {\r\n      throw new Error(\r\n        `Cannot get the parent of path [${path}] because it does not exist in the root.`\r\n      )\r\n    }\r\n\r\n    return p\r\n  }\r\n\r\n  /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */\r\n\r\n  export const text = (node: Node): string => {\r\n    if (Text.isText(node)) {\r\n      return node.text\r\n    } else {\r\n      return node.children.map(Node.text).join('')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return an iterable of all leaf text nodes in a root node.\r\n   */\r\n\r\n  export function* texts(\r\n    root: Node,\r\n    options: {\r\n      from?: Path\r\n      to?: Path\r\n      reverse?: boolean\r\n      pass?: (node: NodeEntry) => boolean\r\n    } = {}\r\n  ): Iterable<TextEntry> {\r\n    for (const [node, path] of Node.nodes(root, options)) {\r\n      if (Text.isText(node)) {\r\n        yield [node, path]\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * The `Descendant` union type represents nodes that are descendants in the\r\n * tree. It is returned as a convenience in certain cases to narrow a value\r\n * further than the more generic `Node` union.\r\n */\r\n\r\nexport type Descendant = Element | Text\r\n\r\n/**\r\n * The `Ancestor` union type represents nodes that are ancestors in the tree.\r\n * It is returned as a convenience in certain cases to narrow a value further\r\n * than the more generic `Node` union.\r\n */\r\n\r\nexport type Ancestor = Value | Element\r\n\r\n/**\r\n * `NodeEntry` objects are returned when iterating over the nodes in a Slate\r\n * document tree. They consist of the node and its `Path` relative to the root\r\n * node in the document.\r\n */\r\n\r\nexport type NodeEntry = [Node, Path]\r\n\r\n/**\r\n * `DescendantEntry` objects are returned when iterating over the descendants in\r\n * a Slate document tree.\r\n */\r\n\r\nexport type DescendantEntry = [Descendant, Path]\r\n\r\n/**\r\n * `AncestorEntry` objects are returned when iterating over the ancestors in a\r\n * Slate document tree.\r\n */\r\n\r\nexport type AncestorEntry = [Ancestor, Path]\r\n\r\n/**\r\n * `NodeMatch` values are used as shorthands for matching a node by either its\r\n * kind, its location, its behavior or its properties.\r\n */\r\n\r\nexport type NodeMatch =\r\n  | 'block'\r\n  | 'element'\r\n  | 'inline'\r\n  | 'inline-element'\r\n  | 'text'\r\n  | 'value'\r\n  | 'void'\r\n  | Partial<Node>\r\n  | ((entry: NodeEntry) => boolean)\r\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","import { Mark, Node, Path, Range, Value } from '..'\r\nimport isPlainObject from 'is-plain-object'\r\n\r\ntype AddAnnotationOperation = {\r\n  type: 'add_annotation'\r\n  key: string\r\n  annotation: Range\r\n  [key: string]: any\r\n}\r\n\r\ntype AddMarkOperation = {\r\n  type: 'add_mark'\r\n  path: Path\r\n  mark: Mark\r\n  [key: string]: any\r\n}\r\n\r\ntype InsertNodeOperation = {\r\n  type: 'insert_node'\r\n  path: Path\r\n  node: Node\r\n  [key: string]: any\r\n}\r\n\r\ntype InsertTextOperation = {\r\n  type: 'insert_text'\r\n  path: Path\r\n  offset: number\r\n  text: string\r\n  [key: string]: any\r\n}\r\n\r\ntype MergeNodeOperation = {\r\n  type: 'merge_node'\r\n  path: Path\r\n  position: number\r\n  target: number | null\r\n  properties: Partial<Node>\r\n  [key: string]: any\r\n}\r\n\r\ntype MoveNodeOperation = {\r\n  type: 'move_node'\r\n  path: Path\r\n  newPath: Path\r\n  [key: string]: any\r\n}\r\n\r\ntype RemoveAnnotationOperation = {\r\n  type: 'remove_annotation'\r\n  key: string\r\n  annotation: Range\r\n  [key: string]: any\r\n}\r\n\r\ntype RemoveMarkOperation = {\r\n  type: 'remove_mark'\r\n  path: Path\r\n  mark: Mark\r\n  [key: string]: any\r\n}\r\n\r\ntype RemoveNodeOperation = {\r\n  type: 'remove_node'\r\n  path: Path\r\n  node: Node\r\n  [key: string]: any\r\n}\r\n\r\ntype RemoveTextOperation = {\r\n  type: 'remove_text'\r\n  path: Path\r\n  offset: number\r\n  text: string\r\n  [key: string]: any\r\n}\r\n\r\ntype SetAnnotationOperation = {\r\n  type: 'set_annotation'\r\n  key: string\r\n  properties: Partial<Range>\r\n  newProperties: Partial<Range>\r\n  [key: string]: any\r\n}\r\n\r\ntype SetMarkOperation = {\r\n  type: 'set_mark'\r\n  path: Path\r\n  properties: Partial<Mark>\r\n  newProperties: Partial<Mark>\r\n  [key: string]: any\r\n}\r\n\r\ntype SetNodeOperation = {\r\n  type: 'set_node'\r\n  path: Path\r\n  properties: Partial<Node>\r\n  newProperties: Partial<Node>\r\n  [key: string]: any\r\n}\r\n\r\ntype SetSelectionOperation =\r\n  | {\r\n      type: 'set_selection'\r\n      [key: string]: any\r\n      properties: null\r\n      newProperties: Range\r\n    }\r\n  | {\r\n      type: 'set_selection'\r\n      [key: string]: any\r\n      properties: Partial<Range>\r\n      newProperties: Partial<Range>\r\n    }\r\n  | {\r\n      type: 'set_selection'\r\n      [key: string]: any\r\n      properties: Range\r\n      newProperties: null\r\n    }\r\n\r\ntype SetValueOperation = {\r\n  type: 'set_value'\r\n  properties: Partial<Value>\r\n  newProperties: Partial<Value>\r\n  [key: string]: any\r\n}\r\n\r\ntype SplitNodeOperation = {\r\n  type: 'split_node'\r\n  path: Path\r\n  position: number\r\n  target: number | null\r\n  properties: Partial<Node>\r\n  [key: string]: any\r\n}\r\n\r\n/**\r\n * `Operation` objects define the low-level instructions that Slate editors use\r\n * to apply changes to their internal state. Representing all changes as\r\n * operations is what allows Slate editors to easily implement history,\r\n * collaboration, and other features.\r\n */\r\n\r\ntype Operation =\r\n  | AnnotationOperation\r\n  | NodeOperation\r\n  | MarkOperation\r\n  | SelectionOperation\r\n  | TextOperation\r\n  | ValueOperation\r\n\r\ntype AnnotationOperation =\r\n  | AddAnnotationOperation\r\n  | RemoveAnnotationOperation\r\n  | SetAnnotationOperation\r\n\r\ntype NodeOperation =\r\n  | InsertNodeOperation\r\n  | MergeNodeOperation\r\n  | MoveNodeOperation\r\n  | RemoveNodeOperation\r\n  | SetNodeOperation\r\n  | SplitNodeOperation\r\n\r\ntype MarkOperation = AddMarkOperation | RemoveMarkOperation | SetMarkOperation\r\n\r\ntype SelectionOperation = SetSelectionOperation\r\n\r\ntype TextOperation = InsertTextOperation | RemoveTextOperation\r\n\r\ntype ValueOperation = SetValueOperation\r\n\r\nnamespace Operation {\r\n  /**\r\n   * Check of a value is an `AnnotationOperation` object.\r\n   */\r\n\r\n  export const isAnnotationOperation = (\r\n    value: any\r\n  ): value is AnnotationOperation => {\r\n    return Operation.isOperation(value) && value.type.endsWith('_annotation')\r\n  }\r\n\r\n  /**\r\n   * Check of a value is a `NodeOperation` object.\r\n   */\r\n\r\n  export const isNodeOperation = (value: any): value is NodeOperation => {\r\n    return Operation.isOperation(value) && value.type.endsWith('_node')\r\n  }\r\n\r\n  /**\r\n   * Check of a value is a `MarkOperation` object.\r\n   */\r\n\r\n  export const isMarkOperation = (value: any): value is MarkOperation => {\r\n    return Operation.isOperation(value) && value.type.endsWith('_mark')\r\n  }\r\n\r\n  /**\r\n   * Check of a value is an `Operation` object.\r\n   */\r\n\r\n  export const isOperation = (value: any): value is Operation => {\r\n    if (!isPlainObject(value)) {\r\n      return false\r\n    }\r\n\r\n    switch (value.type) {\r\n      case 'add_mark': {\r\n        return Path.isPath(value.path) && Mark.isMark(value.mark)\r\n      }\r\n\r\n      case 'add_annotation': {\r\n        return typeof value.key === 'string' && Range.isRange(value.annotation)\r\n      }\r\n\r\n      case 'insert_node': {\r\n        return Path.isPath(value.path) && Node.isNode(value.node)\r\n      }\r\n\r\n      case 'insert_text': {\r\n        return (\r\n          typeof value.offset === 'number' &&\r\n          typeof value.text === 'string' &&\r\n          Path.isPath(value.path)\r\n        )\r\n      }\r\n\r\n      case 'merge_node': {\r\n        return (\r\n          typeof value.position === 'number' &&\r\n          (typeof value.target === 'number' || value.target === null) &&\r\n          Path.isPath(value.path) &&\r\n          isPlainObject(value.properties)\r\n        )\r\n      }\r\n\r\n      case 'move_node': {\r\n        return Path.isPath(value.path) && Path.isPath(value.newPath)\r\n      }\r\n\r\n      case 'remove_annotation': {\r\n        return typeof value.key === 'string' && Range.isRange(value.annotation)\r\n      }\r\n\r\n      case 'remove_mark': {\r\n        return Path.isPath(value.path) && Mark.isMark(value.mark)\r\n      }\r\n\r\n      case 'remove_node': {\r\n        return Path.isPath(value.path) && Node.isNode(value.node)\r\n      }\r\n\r\n      case 'remove_text': {\r\n        return (\r\n          typeof value.offset === 'number' &&\r\n          typeof value.text === 'string' &&\r\n          Path.isPath(value.path)\r\n        )\r\n      }\r\n\r\n      case 'set_annotation': {\r\n        return (\r\n          typeof value.key === 'string' &&\r\n          isPlainObject(value.properties) &&\r\n          isPlainObject(value.newProperties)\r\n        )\r\n      }\r\n\r\n      case 'set_mark': {\r\n        return (\r\n          Path.isPath(value.path) &&\r\n          isPlainObject(value.properties) &&\r\n          isPlainObject(value.newProperties)\r\n        )\r\n      }\r\n\r\n      case 'set_node': {\r\n        return (\r\n          Path.isPath(value.path) &&\r\n          isPlainObject(value.properties) &&\r\n          isPlainObject(value.newProperties)\r\n        )\r\n      }\r\n\r\n      case 'set_selection': {\r\n        return (\r\n          isPlainObject(value.properties) && isPlainObject(value.newProperties)\r\n        )\r\n      }\r\n\r\n      case 'set_value': {\r\n        return (\r\n          isPlainObject(value.properties) && isPlainObject(value.newProperties)\r\n        )\r\n      }\r\n\r\n      case 'split_node': {\r\n        return (\r\n          Path.isPath(value.path) &&\r\n          typeof value.position === 'number' &&\r\n          (typeof value.target === 'number' || value.target === null) &&\r\n          isPlainObject(value.properties)\r\n        )\r\n      }\r\n\r\n      default: {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */\r\n\r\n  export const isOperationList = (value: any): value is Operation[] => {\r\n    return (\r\n      Array.isArray(value) &&\r\n      (value.length === 0 || Operation.isOperation(value[0]))\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check of a value is a `SelectionOperation` object.\r\n   */\r\n\r\n  export const isSelectionOperation = (\r\n    value: any\r\n  ): value is SelectionOperation => {\r\n    return Operation.isOperation(value) && value.type.endsWith('_selection')\r\n  }\r\n\r\n  /**\r\n   * Check of a value is a `TextOperation` object.\r\n   */\r\n\r\n  export const isTextOperation = (value: any): value is TextOperation => {\r\n    return Operation.isOperation(value) && value.type.endsWith('_text')\r\n  }\r\n\r\n  /**\r\n   * Check of a value is a `ValueOperation` object.\r\n   */\r\n\r\n  export const isValueOperation = (value: any): value is ValueOperation => {\r\n    return Operation.isOperation(value) && value.type.endsWith('_value')\r\n  }\r\n\r\n  /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */\r\n\r\n  export const inverse = (op: Operation): Operation => {\r\n    switch (op.type) {\r\n      case 'add_annotation': {\r\n        return { ...op, type: 'remove_annotation' }\r\n      }\r\n\r\n      case 'add_mark': {\r\n        return { ...op, type: 'remove_mark' }\r\n      }\r\n\r\n      case 'insert_node': {\r\n        return { ...op, type: 'remove_node' }\r\n      }\r\n\r\n      case 'insert_text': {\r\n        return { ...op, type: 'remove_text' }\r\n      }\r\n\r\n      case 'merge_node': {\r\n        return { ...op, type: 'split_node', path: Path.previous(op.path) }\r\n      }\r\n\r\n      case 'move_node': {\r\n        const { newPath, path } = op\r\n\r\n        // PERF: in this case the move operation is a no-op anyways.\r\n        if (Path.equals(newPath, path)) {\r\n          return op\r\n        }\r\n\r\n        // We need to get the original path here, but sometimes the `newPath`\r\n        // is a younger sibling of (or ends before) the original, and this\r\n        // accounts for it.\r\n        const inversePath = Path.transform(path, op)!\r\n        const inverseNewPath = Path.transform(Path.next(path), op)!\r\n        return { ...op, path: inversePath, newPath: inverseNewPath }\r\n      }\r\n\r\n      case 'remove_annotation': {\r\n        return { ...op, type: 'add_annotation' }\r\n      }\r\n\r\n      case 'remove_mark': {\r\n        return { ...op, type: 'add_mark' }\r\n      }\r\n\r\n      case 'remove_node': {\r\n        return { ...op, type: 'insert_node' }\r\n      }\r\n\r\n      case 'remove_text': {\r\n        return { ...op, type: 'insert_text' }\r\n      }\r\n\r\n      case 'set_annotation':\r\n      case 'set_mark':\r\n      case 'set_node':\r\n      case 'set_value': {\r\n        const { properties, newProperties } = op\r\n        return { ...op, properties: newProperties, newProperties: properties }\r\n      }\r\n\r\n      case 'set_selection': {\r\n        const { properties, newProperties } = op\r\n\r\n        if (properties == null) {\r\n          return {\r\n            ...op,\r\n            properties: newProperties as Range,\r\n            newProperties: null,\r\n          }\r\n        } else if (newProperties == null) {\r\n          return {\r\n            ...op,\r\n            properties: null,\r\n            newProperties: properties as Range,\r\n          }\r\n        } else {\r\n          return { ...op, properties: newProperties, newProperties: properties }\r\n        }\r\n      }\r\n\r\n      case 'split_node': {\r\n        return { ...op, type: 'merge_node', path: Path.next(op.path) }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport {\r\n  AddMarkOperation,\r\n  AddAnnotationOperation,\r\n  InsertNodeOperation,\r\n  InsertTextOperation,\r\n  MergeNodeOperation,\r\n  MoveNodeOperation,\r\n  RemoveAnnotationOperation,\r\n  RemoveMarkOperation,\r\n  RemoveNodeOperation,\r\n  RemoveTextOperation,\r\n  SetAnnotationOperation,\r\n  SetMarkOperation,\r\n  SetNodeOperation,\r\n  SetSelectionOperation,\r\n  SetValueOperation,\r\n  SplitNodeOperation,\r\n  Operation,\r\n}\r\n","import { produce } from 'immer'\r\nimport { Operation } from '..'\r\n\r\n/**\r\n * `Path` arrays are a list of indexes that describe a node's exact position in\r\n * a Slate node tree. Although they are usually relative to the root `Value`\r\n * object, they can be relative to any `Node` object.\r\n */\r\n\r\ntype Path = number[]\r\n\r\nnamespace Path {\r\n  /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */\r\n\r\n  export const ancestors = (\r\n    path: Path,\r\n    options: { reverse?: boolean } = {}\r\n  ): Path[] => {\r\n    const { reverse = false } = options\r\n    let paths = Path.levels(path, options)\r\n\r\n    if (reverse) {\r\n      paths = paths.slice(1)\r\n    } else {\r\n      paths = paths.slice(0, -1)\r\n    }\r\n\r\n    return paths\r\n  }\r\n\r\n  /**\r\n   * Get the common ancestor path of two paths.\r\n   */\r\n\r\n  export const common = (path: Path, another: Path): Path => {\r\n    const common: Path = []\r\n\r\n    for (let i = 0; i < path.length && i < another.length; i++) {\r\n      const av = path[i]\r\n      const bv = another[i]\r\n\r\n      if (av !== bv) {\r\n        break\r\n      }\r\n\r\n      common.push(av)\r\n    }\r\n\r\n    return common\r\n  }\r\n\r\n  /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */\r\n\r\n  export const compare = (path: Path, another: Path): -1 | 0 | 1 => {\r\n    const min = Math.min(path.length, another.length)\r\n\r\n    for (let i = 0; i < min; i++) {\r\n      if (path[i] < another[i]) return -1\r\n      if (path[i] > another[i]) return 1\r\n    }\r\n\r\n    return 0\r\n  }\r\n\r\n  /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */\r\n\r\n  export const endsAfter = (path: Path, another: Path): boolean => {\r\n    const i = path.length - 1\r\n    const as = path.slice(0, i)\r\n    const bs = another.slice(0, i)\r\n    const av = path[i]\r\n    const bv = another[i]\r\n    return Path.equals(as, bs) && av > bv\r\n  }\r\n\r\n  /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */\r\n\r\n  export const endsAt = (path: Path, another: Path): boolean => {\r\n    const i = path.length\r\n    const as = path.slice(0, i)\r\n    const bs = another.slice(0, i)\r\n    return Path.equals(as, bs)\r\n  }\r\n\r\n  /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */\r\n\r\n  export const endsBefore = (path: Path, another: Path): boolean => {\r\n    const i = path.length - 1\r\n    const as = path.slice(0, i)\r\n    const bs = another.slice(0, i)\r\n    const av = path[i]\r\n    const bv = another[i]\r\n    return Path.equals(as, bs) && av < bv\r\n  }\r\n\r\n  /**\r\n   * Check if a path is exactly equal to another.\r\n   */\r\n\r\n  export const equals = (path: Path, another: Path): boolean => {\r\n    return (\r\n      path.length === another.length && path.every((n, i) => n === another[i])\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if a path is after another.\r\n   */\r\n\r\n  export const isAfter = (path: Path, another: Path): boolean => {\r\n    return Path.compare(path, another) === 1\r\n  }\r\n\r\n  /**\r\n   * Check if a path is an ancestor of another.\r\n   */\r\n\r\n  export const isAncestor = (path: Path, another: Path): boolean => {\r\n    return path.length < another.length && Path.compare(path, another) === 0\r\n  }\r\n\r\n  /**\r\n   * Check if a path is before another.\r\n   */\r\n\r\n  export const isBefore = (path: Path, another: Path): boolean => {\r\n    return Path.compare(path, another) === -1\r\n  }\r\n\r\n  /**\r\n   * Check if a path is a child of another.\r\n   */\r\n\r\n  export const isChild = (path: Path, another: Path): boolean => {\r\n    return (\r\n      path.length === another.length + 1 && Path.compare(path, another) === 0\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */\r\n\r\n  export const isCommon = (path: Path, another: Path): boolean => {\r\n    return path.length <= another.length && Path.compare(path, another) === 0\r\n  }\r\n\r\n  /**\r\n   * Check if a path is a descendant of another.\r\n   */\r\n\r\n  export const isDescendant = (path: Path, another: Path): boolean => {\r\n    return path.length > another.length && Path.compare(path, another) === 0\r\n  }\r\n\r\n  /**\r\n   * Check if a path is the parent of another.\r\n   */\r\n\r\n  export const isParent = (path: Path, another: Path): boolean => {\r\n    return (\r\n      path.length + 1 === another.length && Path.compare(path, another) === 0\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check is a value implements the `Path` interface.\r\n   */\r\n\r\n  export const isPath = (value: any): value is Path => {\r\n    return (\r\n      Array.isArray(value) &&\r\n      (value.length === 0 || typeof value[0] === 'number')\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if a path is a sibling of another.\r\n   */\r\n\r\n  export const isSibling = (path: Path, another: Path): boolean => {\r\n    if (path.length !== another.length) {\r\n      return false\r\n    }\r\n\r\n    const as = path.slice(0, -1)\r\n    const bs = another.slice(0, -1)\r\n    const al = path[path.length - 1]\r\n    const bl = another[another.length - 1]\r\n    return al !== bl && Path.equals(as, bs)\r\n  }\r\n\r\n  /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */\r\n\r\n  export const levels = (\r\n    path: Path,\r\n    options: {\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Path[] => {\r\n    const { reverse = false } = options\r\n    const list: Path[] = []\r\n\r\n    for (let i = 0; i <= path.length; i++) {\r\n      list.push(path.slice(0, i))\r\n    }\r\n\r\n    if (reverse) {\r\n      list.reverse()\r\n    }\r\n\r\n    return list\r\n  }\r\n\r\n  /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */\r\n\r\n  export const next = (path: Path): Path => {\r\n    if (path.length === 0) {\r\n      throw new Error(\r\n        `Cannot get the next path of a root path [${path}], because it has no next index.`\r\n      )\r\n    }\r\n\r\n    const last = path[path.length - 1]\r\n    return path.slice(0, -1).concat(last + 1)\r\n  }\r\n\r\n  /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */\r\n\r\n  export const parent = (path: Path): Path => {\r\n    if (path.length === 0) {\r\n      throw new Error(`Cannot get the parent path of the root path [${path}].`)\r\n    }\r\n\r\n    return path.slice(0, -1)\r\n  }\r\n\r\n  /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */\r\n\r\n  export const previous = (path: Path): Path => {\r\n    if (path.length === 0) {\r\n      throw new Error(\r\n        `Cannot get the previous path of a root path [${path}], because it has no previous index.`\r\n      )\r\n    }\r\n\r\n    const last = path[path.length - 1]\r\n\r\n    if (last <= 0) {\r\n      throw new Error(\r\n        `Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`\r\n      )\r\n    }\r\n\r\n    return path.slice(0, -1).concat(last - 1)\r\n  }\r\n\r\n  /**\r\n   * Get a path relative to an ancestor.\r\n   */\r\n\r\n  export const relative = (path: Path, ancestor: Path): Path => {\r\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\r\n      throw new Error(\r\n        `Cannot get the relative path of [${path}] inside ancestor [${ancestor}], because it is not above or equal to the path.`\r\n      )\r\n    }\r\n\r\n    return path.slice(ancestor.length)\r\n  }\r\n\r\n  /**\r\n   * Transform a path by an operation.\r\n   */\r\n\r\n  export const transform = (\r\n    path: Path,\r\n    operation: Operation,\r\n    options: { affinity?: 'forward' | 'backward' | null } = {}\r\n  ): Path | null => {\r\n    return produce(path, p => {\r\n      const { affinity = 'forward' } = options\r\n\r\n      // PERF: Exit early if the operation is guaranteed not to have an effect.\r\n      if (path.length === 0) {\r\n        return\r\n      }\r\n\r\n      switch (operation.type) {\r\n        case 'insert_node': {\r\n          const { path: op } = operation\r\n\r\n          if (\r\n            Path.equals(op, p) ||\r\n            Path.endsBefore(op, p) ||\r\n            Path.isAncestor(op, p)\r\n          ) {\r\n            p[op.length - 1] += 1\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'remove_node': {\r\n          const { path: op } = operation\r\n\r\n          if (Path.equals(op, p) || Path.isAncestor(op, p)) {\r\n            return null\r\n          } else if (Path.endsBefore(op, p)) {\r\n            p[op.length - 1] -= 1\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'merge_node': {\r\n          const { path: op, position } = operation\r\n\r\n          if (Path.equals(op, p) || Path.endsBefore(op, p)) {\r\n            p[op.length - 1] -= 1\r\n          } else if (Path.isAncestor(op, p)) {\r\n            p[op.length - 1] -= 1\r\n            p[op.length] += position\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'split_node': {\r\n          const { path: op, position } = operation\r\n\r\n          if (Path.equals(op, p)) {\r\n            if (affinity === 'forward') {\r\n              p[p.length - 1] += 1\r\n            } else if (affinity === 'backward') {\r\n              // Nothing, because it still refers to the right path.\r\n            } else {\r\n              return null\r\n            }\r\n          } else if (Path.endsBefore(op, p)) {\r\n            p[op.length - 1] += 1\r\n          } else if (Path.isAncestor(op, p) && path[op.length] >= position) {\r\n            p[op.length - 1] += 1\r\n            p[op.length] -= position\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'move_node': {\r\n          const { path: op, newPath: onp } = operation\r\n\r\n          // If the old and new path are the same, it's a no-op.\r\n          if (Path.equals(op, onp)) {\r\n            return\r\n          }\r\n\r\n          if (Path.isAncestor(op, p) || Path.equals(op, p)) {\r\n            const copy = onp.slice()\r\n\r\n            if (Path.endsBefore(op, onp) && op.length < onp.length) {\r\n              const i = Math.min(onp.length, op.length) - 1\r\n              copy[i] -= 1\r\n            }\r\n\r\n            return copy.concat(p.slice(op.length))\r\n          } else if (\r\n            Path.endsBefore(onp, p) ||\r\n            Path.equals(onp, p) ||\r\n            Path.isAncestor(onp, p)\r\n          ) {\r\n            if (Path.endsBefore(op, p)) {\r\n              p[op.length - 1] -= 1\r\n            }\r\n\r\n            p[onp.length - 1] += 1\r\n          } else if (Path.endsBefore(op, p)) {\r\n            if (Path.equals(onp, p)) {\r\n              p[onp.length - 1] += 1\r\n            }\r\n\r\n            p[op.length - 1] -= 1\r\n          }\r\n\r\n          break\r\n        }\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport { Path }\r\n","import isPlainObject from 'is-plain-object'\r\nimport { produce } from 'immer'\r\nimport { Operation, Path } from '..'\r\n\r\n/**\r\n * `Point` objects refer to a specific location in a text node in a Slate\r\n * document. Its path refers to the location of the node in the tree, and its\r\n * offset refers to the distance into the node's string of text. Points can\r\n * only refer to `Text` nodes.\r\n */\r\n\r\ninterface Point {\r\n  path: Path\r\n  offset: number\r\n  [key: string]: any\r\n}\r\n\r\n/**\r\n * `PointKey` is either an \"anchor\" or \"focus\" point string.\r\n */\r\n\r\ntype PointKey = 'anchor' | 'focus'\r\n\r\nnamespace Point {\r\n  /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */\r\n\r\n  export const compare = (point: Point, another: Point): -1 | 0 | 1 => {\r\n    const result = Path.compare(point.path, another.path)\r\n\r\n    if (result === 0) {\r\n      if (point.offset < another.offset) return -1\r\n      if (point.offset > another.offset) return 1\r\n      return 0\r\n    }\r\n\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * Check if a point is after another.\r\n   */\r\n\r\n  export const isAfter = (point: Point, another: Point): boolean => {\r\n    return Point.compare(point, another) === 1\r\n  }\r\n\r\n  /**\r\n   * Check if a point is before another.\r\n   */\r\n\r\n  export const isBefore = (point: Point, another: Point): boolean => {\r\n    return Point.compare(point, another) === -1\r\n  }\r\n\r\n  /**\r\n   * Check if a point is exactly equal to another.\r\n   */\r\n\r\n  export const equals = (point: Point, another: Point): boolean => {\r\n    // PERF: We could compare to a result of `0` here, but it's slightly faster\r\n    // to first ensure the offsets are equal and to use `Path.equals`.\r\n    return (\r\n      point.offset === another.offset && Path.equals(point.path, another.path)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if a value implements the `Point` interface.\r\n   */\r\n\r\n  export const isPoint = (value: any): value is Point => {\r\n    return (\r\n      isPlainObject(value) &&\r\n      typeof value.offset === 'number' &&\r\n      Path.isPath(value.path)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Transform a point by an operation.\r\n   */\r\n\r\n  export const transform = (\r\n    point: Point,\r\n    op: Operation,\r\n    options: { affinity?: 'forward' | 'backward' | null } = {}\r\n  ): Point | null => {\r\n    return produce(point, p => {\r\n      const { affinity = 'forward' } = options\r\n      const { path, offset } = p\r\n\r\n      switch (op.type) {\r\n        case 'insert_node':\r\n        case 'move_node': {\r\n          p.path = Path.transform(path, op, options)!\r\n          break\r\n        }\r\n\r\n        case 'insert_text': {\r\n          if (Path.equals(op.path, path) && op.offset <= offset) {\r\n            p.offset += op.text.length\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'merge_node': {\r\n          if (Path.equals(op.path, path)) {\r\n            p.offset += op.position\r\n          }\r\n\r\n          p.path = Path.transform(path, op, options)!\r\n          break\r\n        }\r\n\r\n        case 'remove_text': {\r\n          if (Path.equals(op.path, path) && op.offset <= offset) {\r\n            p.offset -= Math.min(offset - op.offset, op.text.length)\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'remove_node': {\r\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\r\n            return null\r\n          }\r\n\r\n          p.path = Path.transform(path, op, options)!\r\n          break\r\n        }\r\n\r\n        case 'split_node': {\r\n          if (Path.equals(op.path, path)) {\r\n            if (op.position === offset && affinity == null) {\r\n              return null\r\n            } else if (\r\n              op.position < offset ||\r\n              (op.position === offset && affinity === 'forward')\r\n            ) {\r\n              p.offset -= op.position\r\n\r\n              p.path = Path.transform(path, op, {\r\n                ...options,\r\n                affinity: 'forward',\r\n              })!\r\n            }\r\n          } else {\r\n            p.path = Path.transform(path, op, options)!\r\n          }\r\n\r\n          break\r\n        }\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport { Point, PointKey }\r\n","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;","import { produce } from 'immer'\r\nimport isPlainObject from 'is-plain-object'\r\nimport { Operation, Path, Point } from '..'\r\n\r\n/**\r\n * `Range` objects are a set of points that refer to a specific span of a Slate\r\n * document. They can define a span inside a single node or a can span across\r\n * multiple nodes.\r\n */\r\n\r\ninterface Range {\r\n  anchor: Point\r\n  focus: Point\r\n  [key: string]: any\r\n}\r\n\r\nnamespace Range {\r\n  export const start = (range: Range): Point => {\r\n    const [start] = Range.edges(range)\r\n    return start\r\n  }\r\n\r\n  export const end = (range: Range): Point => {\r\n    const [, end] = Range.edges(range)\r\n    return end\r\n  }\r\n\r\n  export const intersection = (range: Range, another: Range): Range | null => {\r\n    const { anchor, focus, ...rest } = range\r\n    const [s1, e1] = Range.edges(range)\r\n    const [s2, e2] = Range.edges(another)\r\n    const start = Point.isBefore(s1, s2) ? s2 : s1\r\n    const end = Point.isBefore(e1, e2) ? e1 : e2\r\n\r\n    if (Point.isBefore(end, start)) {\r\n      return null\r\n    } else {\r\n      return { anchor: start, focus: end, ...rest }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a range is exactly equal to another.\r\n   */\r\n\r\n  export const equals = (range: Range, another: Range): boolean => {\r\n    return (\r\n      Point.equals(range.anchor, another.anchor) &&\r\n      Point.equals(range.focus, another.focus)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if a range exists in a list or map of ranges.\r\n   */\r\n\r\n  export const exists = (\r\n    range: Range,\r\n    target: Range[] | Record<string, Range>\r\n  ): boolean => {\r\n    if (Range.isRangeList(target)) {\r\n      return !!target.find(r => Range.equals(r, range))\r\n    }\r\n\r\n    if (Range.isRangeMap(target)) {\r\n      for (const key in target) {\r\n        if (Range.equals(range, target[key])) {\r\n          return true\r\n        }\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */\r\n\r\n  export const includes = (\r\n    range: Range,\r\n    target: Path | Point | Range\r\n  ): boolean => {\r\n    if (Range.isRange(target)) {\r\n      if (\r\n        Range.includes(range, target.anchor) ||\r\n        Range.includes(range, target.focus)\r\n      ) {\r\n        return true\r\n      }\r\n\r\n      const [rs, re] = Range.edges(range)\r\n      const [ts, te] = Range.edges(target)\r\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te)\r\n    }\r\n\r\n    const [start, end] = Range.edges(range)\r\n    let isAfterStart = false\r\n    let isBeforeEnd = false\r\n\r\n    if (Point.isPoint(target)) {\r\n      isAfterStart = Point.compare(target, start) >= 0\r\n      isBeforeEnd = Point.compare(target, end) <= 0\r\n    } else {\r\n      isAfterStart = Path.compare(target, start.path) >= 0\r\n      isBeforeEnd = Path.compare(target, end.path) <= 0\r\n    }\r\n\r\n    return isAfterStart && isBeforeEnd\r\n  }\r\n\r\n  /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */\r\n\r\n  export const isBackward = (range: Range): boolean => {\r\n    const { anchor, focus } = range\r\n    return Point.isAfter(anchor, focus)\r\n  }\r\n\r\n  /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */\r\n\r\n  export const isCollapsed = (range: Range): boolean => {\r\n    const { anchor, focus } = range\r\n    return Point.equals(anchor, focus)\r\n  }\r\n\r\n  /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */\r\n\r\n  export const isExpanded = (range: Range): boolean => {\r\n    return !isCollapsed(range)\r\n  }\r\n\r\n  /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */\r\n\r\n  export const isForward = (range: Range): boolean => {\r\n    return !isBackward(range)\r\n  }\r\n\r\n  /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */\r\n\r\n  export const isRange = (value: any): value is Range => {\r\n    return (\r\n      isPlainObject(value) &&\r\n      Point.isPoint(value.anchor) &&\r\n      Point.isPoint(value.focus)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if a value is an array of `Range` objects.\r\n   */\r\n\r\n  export const isRangeList = (value: any): value is Range[] => {\r\n    return (\r\n      Array.isArray(value) && (value.length === 0 || Range.isRange(value[0]))\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if a value is a map of `Range` objects.\r\n   */\r\n\r\n  export const isRangeMap = (value: any): value is Record<string, Range> => {\r\n    if (!isPlainObject(value)) {\r\n      return false\r\n    }\r\n\r\n    for (const key in value) {\r\n      return Range.isRange(value[key])\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */\r\n\r\n  export const edges = (\r\n    range: Range,\r\n    options: {\r\n      reverse?: boolean\r\n    } = {}\r\n  ): [Point, Point] => {\r\n    const { reverse = false } = options\r\n    const { anchor, focus } = range\r\n    return Range.isBackward(range) === reverse\r\n      ? [anchor, focus]\r\n      : [focus, anchor]\r\n  }\r\n\r\n  /**\r\n   * Transform a range by an operation.\r\n   */\r\n\r\n  export const transform = (\r\n    range: Range,\r\n    op: Operation,\r\n    options: { affinity: 'forward' | 'backward' | 'outward' | 'inward' | null }\r\n  ): Range | null => {\r\n    const { affinity = 'inward' } = options\r\n    let affinityAnchor: 'forward' | 'backward' | null\r\n    let affinityFocus: 'forward' | 'backward' | null\r\n\r\n    if (affinity === 'inward') {\r\n      if (Range.isForward(range)) {\r\n        affinityAnchor = 'forward'\r\n        affinityFocus = 'backward'\r\n      } else {\r\n        affinityAnchor = 'backward'\r\n        affinityFocus = 'forward'\r\n      }\r\n    } else if (affinity === 'outward') {\r\n      if (Range.isForward(range)) {\r\n        affinityAnchor = 'backward'\r\n        affinityFocus = 'forward'\r\n      } else {\r\n        affinityAnchor = 'forward'\r\n        affinityFocus = 'backward'\r\n      }\r\n    } else {\r\n      affinityAnchor = affinity\r\n      affinityFocus = affinity\r\n    }\r\n\r\n    return produce(range, r => {\r\n      const anchor = Point.transform(r.anchor, op, { affinity: affinityAnchor })\r\n      const focus = Point.transform(r.focus, op, { affinity: affinityFocus })\r\n\r\n      if (!anchor || !focus) {\r\n        return null\r\n      }\r\n\r\n      r.anchor = anchor\r\n      r.focus = focus\r\n    })\r\n  }\r\n}\r\n\r\nexport { Range }\r\n","import isPlainObject from 'is-plain-object'\r\nimport { Mark, Path } from '..'\r\n\r\n/**\r\n * `Text` objects represent the nodes that contain the actual text content of a\r\n * Slate document along with any formatting marks. They are always leaf nodes in\r\n * the document tree as they cannot contain any children.\r\n */\r\n\r\ninterface Text {\r\n  text: string\r\n  marks: Mark[]\r\n  [key: string]: any\r\n}\r\n\r\n/**\r\n * `TextEntry` objects refer to an `Text` and the `Path` where it can be\r\n * found inside a root node.\r\n */\r\n\r\ntype TextEntry = [Text, Path]\r\n\r\nnamespace Text {\r\n  /**\r\n   * Check if a value implements the `Text` interface.\r\n   */\r\n\r\n  export const isText = (value: any): value is Text => {\r\n    return (\r\n      isPlainObject(value) &&\r\n      typeof value.text === 'string' &&\r\n      Array.isArray(value.marks)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */\r\n\r\n  export const isTextList = (value: any): value is Text[] => {\r\n    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]))\r\n  }\r\n\r\n  /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal. However, if `marks` are passed it\r\n   * will ensure that the set of marks is exactly equal.\r\n   */\r\n\r\n  export const matches = (text: Text, props: Partial<Text>): boolean => {\r\n    for (const key in props) {\r\n      if (key === 'text') {\r\n        continue\r\n      }\r\n\r\n      if (key === 'marks' && props.marks != null) {\r\n        const existing = text.marks\r\n        const { marks } = props\r\n\r\n        // PERF: If the lengths aren't the same, we know it's not a match.\r\n        if (existing.length !== marks.length) {\r\n          return false\r\n        }\r\n\r\n        for (const m of existing) {\r\n          if (!Mark.exists(m, marks)) {\r\n            return false\r\n          }\r\n        }\r\n\r\n        for (const m of marks) {\r\n          if (!Mark.exists(m, existing)) {\r\n            return false\r\n          }\r\n        }\r\n\r\n        continue\r\n      }\r\n\r\n      if (text[key] !== props[key]) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\nexport { Text, TextEntry }\r\n","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","import isPlainObject from 'is-plain-object'\r\nimport { produce } from 'immer'\r\nimport {\r\n  Element,\r\n  Mark,\r\n  Node,\r\n  Operation,\r\n  Path,\r\n  Point,\r\n  PointKey,\r\n  Range,\r\n  Descendant,\r\n  Text,\r\n} from '..'\r\n\r\n/**\r\n * `Value` objects hold all of the state in a Slate editor, including all of the\r\n * nodes in the document and the user's currently selected range of text.\r\n */\r\n\r\nexport interface Value extends Element {\r\n  selection: Range | null\r\n  annotations: Record<string, Range>\r\n  [key: string]: any\r\n}\r\n\r\nexport namespace Value {\r\n  /**\r\n   * Check if a value implements the `Value` interface.\r\n   */\r\n\r\n  export const isValue = (value: any): value is Value => {\r\n    return (\r\n      isPlainObject(value) &&\r\n      (value.selection === null || Range.isRange(value.selection)) &&\r\n      Node.isNodeList(value.children) &&\r\n      Range.isRangeMap(value.annotations)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if a value matches a set of properties.\r\n   *\r\n   * Note: the is for checking custom properties, and it does not ensure that\r\n   * any children in the `nodes` property are equal.\r\n   */\r\n\r\n  export const matches = (value: Value, props: Partial<Value>): boolean => {\r\n    for (const key in props) {\r\n      if (key === 'annotations' || key === 'children' || key === 'selection') {\r\n        continue\r\n      }\r\n\r\n      if (value[key] !== props[key]) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Iterate through all of the point objects in a value.\r\n   */\r\n\r\n  export function* points(\r\n    value: Value\r\n  ): Iterable<SelectionPointEntry | AnnotationPointEntry> {\r\n    const { selection, annotations } = value\r\n\r\n    if (selection != null) {\r\n      yield [selection.anchor, 'anchor', selection]\r\n      yield [selection.focus, 'focus', selection]\r\n    }\r\n\r\n    for (const key in annotations) {\r\n      const annotation = annotations[key]\r\n      yield [annotation.anchor, 'anchor', annotation, key]\r\n      yield [annotation.focus, 'focus', annotation, key]\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Transform a value by an operation.\r\n   */\r\n\r\n  export const transform = (value: Value, op: Operation): Value => {\r\n    return produce(value, v => {\r\n      switch (op.type) {\r\n        case 'add_annotation': {\r\n          const { annotation, key } = op\r\n          v.annotations[key] = annotation\r\n          break\r\n        }\r\n\r\n        case 'add_mark': {\r\n          const { path, mark } = op\r\n          const node = Node.leaf(v, path)\r\n\r\n          if (!Mark.exists(mark, node.marks)) {\r\n            node.marks.push(mark)\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'insert_node': {\r\n          const { path, node } = op\r\n          const parent = Node.parent(v, path)\r\n          const index = path[path.length - 1]\r\n          parent.children.splice(index, 0, node)\r\n\r\n          for (const [point, key, range] of Value.points(v)) {\r\n            range[key] = Point.transform(point, op)!\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'insert_text': {\r\n          const { path, offset, text } = op\r\n          const node = Node.leaf(v, path)\r\n          const before = node.text.slice(0, offset)\r\n          const after = node.text.slice(offset)\r\n          node.text = before + text + after\r\n\r\n          for (const [point, key, range] of Value.points(v)) {\r\n            range[key] = Point.transform(point, op)!\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'merge_node': {\r\n          const { path } = op\r\n          const node = Node.get(v, path)\r\n          const prevPath = Path.previous(path)\r\n          const prev = Node.get(v, prevPath)\r\n          const parent = Node.parent(v, path)\r\n          const index = path[path.length - 1]\r\n\r\n          if (Text.isText(node) && Text.isText(prev)) {\r\n            prev.text += node.text\r\n          } else if (!Text.isText(node) && !Text.isText(prev)) {\r\n            prev.children.push(...node.children)\r\n          } else {\r\n            throw new Error(\r\n              `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interaces: ${node} ${prev}`\r\n            )\r\n          }\r\n\r\n          parent.children.splice(index, 1)\r\n\r\n          for (const [point, key, range] of Value.points(v)) {\r\n            range[key] = Point.transform(point, op)!\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'move_node': {\r\n          const { path, newPath } = op\r\n\r\n          if (Path.isAncestor(path, newPath)) {\r\n            throw new Error(\r\n              `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\r\n            )\r\n          }\r\n\r\n          const node = Node.get(v, path)\r\n          const parent = Node.parent(v, path)\r\n          const index = path[path.length - 1]\r\n\r\n          // This is tricky, but since the `path` and `newPath` both refer to\r\n          // the same snapshot in time, there's a mismatch. After either\r\n          // removing the original position, the second step's path can be out\r\n          // of date. So instead of using the `op.newPath` directly, we\r\n          // transform `op.path` to ascertain what the `newPath` would be after\r\n          // the operation was applied.\r\n          parent.children.splice(index, 1)\r\n          const truePath = Path.transform(path, op)!\r\n          const newParent = Node.get(v, Path.parent(truePath))\r\n          const newIndex = truePath[truePath.length - 1]\r\n\r\n          newParent.children.splice(newIndex, 0, node)\r\n\r\n          for (const [point, key, range] of Value.points(v)) {\r\n            range[key] = Point.transform(point, op)!\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'remove_annotation': {\r\n          const { key } = op\r\n          delete v.annotations[key]\r\n          break\r\n        }\r\n\r\n        case 'remove_mark': {\r\n          const { path, mark } = op\r\n          const node = Node.leaf(v, path)\r\n\r\n          for (let i = 0; i < node.marks.length; i++) {\r\n            if (Mark.matches(node.marks[i], mark)) {\r\n              node.marks.splice(i, 1)\r\n              break\r\n            }\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'remove_node': {\r\n          const { path } = op\r\n          const index = path[path.length - 1]\r\n          const parent = Node.parent(v, path)\r\n          const [, prev] = Node.texts(v, { from: path, reverse: true })\r\n          const [, next] = Node.texts(v, { from: path })\r\n          parent.children.splice(index, 1)\r\n\r\n          // Transform all of the points in the value, but if the point was in the\r\n          // node that was removed we need to update the range or remove it.\r\n          for (const [point, k, range, key] of Value.points(v)) {\r\n            const result = Point.transform(point, op)\r\n\r\n            if (result != null) {\r\n              range[k] = result\r\n            } else if (prev) {\r\n              const [prevNode, prevPath] = prev\r\n              point.path = prevPath\r\n              point.offset = prevNode.text.length\r\n            } else if (next) {\r\n              const [, nextPath] = next\r\n              const newNextPath = Path.transform(nextPath, op)!\r\n              point.path = newNextPath\r\n              point.offset = 0\r\n            } else if (key != null) {\r\n              delete v.annotations[key]\r\n            } else {\r\n              v.selection = null\r\n            }\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'remove_text': {\r\n          const { path, offset, text } = op\r\n          const node = Node.leaf(v, path)\r\n          const before = node.text.slice(0, offset)\r\n          const after = node.text.slice(offset + text.length)\r\n          node.text = before + after\r\n\r\n          for (const [point, key, range] of Value.points(v)) {\r\n            range[key] = Point.transform(point, op)!\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'set_annotation': {\r\n          const { key, newProperties } = op\r\n          const annotation = v.annotations[key]\r\n          Object.assign(annotation, newProperties)\r\n          break\r\n        }\r\n\r\n        case 'set_mark': {\r\n          const { path, properties, newProperties } = op\r\n          const node = Node.leaf(v, path)\r\n\r\n          for (const mark of node.marks) {\r\n            if (Mark.matches(mark, properties)) {\r\n              Object.assign(mark, newProperties)\r\n              break\r\n            }\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'set_node': {\r\n          const { path, newProperties } = op\r\n          const node = Node.get(v, path)\r\n          Object.assign(node, newProperties)\r\n          break\r\n        }\r\n\r\n        case 'set_selection': {\r\n          const { newProperties } = op\r\n\r\n          if (newProperties == null) {\r\n            v.selection = newProperties\r\n          } else if (v.selection == null) {\r\n            if (!Range.isRange(newProperties)) {\r\n              throw new Error(\r\n                `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\r\n                  newProperties\r\n                )} when there is no current selection.`\r\n              )\r\n            }\r\n\r\n            v.selection = newProperties\r\n          } else {\r\n            Object.assign(v.selection, newProperties)\r\n          }\r\n\r\n          break\r\n        }\r\n\r\n        case 'set_value': {\r\n          const { newProperties } = op\r\n          Object.assign(v, newProperties)\r\n          break\r\n        }\r\n\r\n        case 'split_node': {\r\n          const { path, position, properties } = op\r\n\r\n          if (path.length === 0) {\r\n            throw new Error(\r\n              `Cannot apply a \"split_node\" operation at path [${path}] because the top-level value cannot be split.`\r\n            )\r\n          }\r\n\r\n          const node = Node.get(v, path)\r\n          const parent = Node.parent(v, path)\r\n          const index = path[path.length - 1]\r\n          let newNode: Descendant\r\n\r\n          if (Text.isText(node)) {\r\n            const before = node.text.slice(0, position)\r\n            const after = node.text.slice(position)\r\n            node.text = before\r\n            newNode = { ...node, ...(properties as Partial<Text>), text: after }\r\n          } else {\r\n            const before = node.children.slice(0, position)\r\n            const after = node.children.slice(position)\r\n            node.children = before\r\n\r\n            newNode = {\r\n              ...node,\r\n              ...(properties as Partial<Element>),\r\n              children: after,\r\n            }\r\n          }\r\n\r\n          parent.children.splice(index + 1, 0, newNode)\r\n\r\n          for (const [point, key, range] of Value.points(v)) {\r\n            range[key] = Point.transform(point, op)!\r\n          }\r\n\r\n          break\r\n        }\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * `ValueEntry` objects refer to an `Value` and the `Path` where it can be\r\n * found inside a root node.\r\n */\r\n\r\nexport type ValueEntry = [Value, Path]\r\n\r\n/**\r\n * `AnnotationEntry` objects are returned when iterating over annotations\r\n * in the top-level value.\r\n */\r\n\r\nexport type AnnotationEntry = [Range, string]\r\n\r\n/**\r\n * `AnnotationMatch` objects are a shorthand for matching annotation objects.\r\n */\r\n\r\nexport type AnnotationMatch =\r\n  | Partial<Range>\r\n  | ((entry: AnnotationEntry) => boolean)\r\n\r\n/**\r\n * `AnnotationPointEntry` objects are returned when iterating over `Point`\r\n * objects that belong to an annotation.\r\n */\r\n\r\nexport type AnnotationPointEntry = [Point, PointKey, Range, string]\r\n\r\n/**\r\n * `SelectionPointEntry` objects are returned when iterating over `Point`\r\n * objects that belong to a selection.\r\n */\r\n\r\nexport type SelectionPointEntry = [Point, PointKey, Range]\r\n","import { Editor, Point, Range } from '../..'\r\n\r\nclass AnnotationCommands {\r\n  /**\r\n   * Add a new `annotation` object with a `key`.\r\n   */\r\n\r\n  addAnnotation(this: Editor, key: string, annotation: Range) {\r\n    this.apply({\r\n      type: 'add_annotation',\r\n      key,\r\n      annotation,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Remove an existing annotation object by `key`.\r\n   */\r\n\r\n  removeAnnotation(this: Editor, key: string) {\r\n    const { annotations } = this.value\r\n\r\n    if (!(key in annotations)) {\r\n      throw new Error(\r\n        `Unable to remove annotation by ${key} because it does not exist.`\r\n      )\r\n    }\r\n\r\n    const annotation = annotations[key]\r\n\r\n    this.apply({\r\n      type: 'remove_annotation',\r\n      key,\r\n      annotation,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Set new properties on an annotation object with `key`.\r\n   */\r\n\r\n  setAnnotation(this: Editor, key: string, props: Partial<Range>) {\r\n    const { annotations } = this.value\r\n\r\n    if (!(key in annotations)) {\r\n      throw new Error(\r\n        `Unable to set new properties on annotation by ${key} because it does not exist.`\r\n      )\r\n    }\r\n\r\n    const annotation = annotations[key]\r\n    const newProps = {}\r\n    const prevProps = {}\r\n\r\n    for (const k in props) {\r\n      const isPoint = k === 'anchor' || k === 'focus'\r\n\r\n      if (\r\n        (isPoint && !Point.equals(props[k], annotation[k])) ||\r\n        (!isPoint && props[k] !== annotation[k])\r\n      ) {\r\n        newProps[k] = props[k]\r\n        prevProps[k] = annotation[k]\r\n      }\r\n    }\r\n\r\n    if (Object.keys(newProps).length > 0) {\r\n      this.apply({\r\n        type: 'set_annotation',\r\n        key,\r\n        properties: prevProps,\r\n        newProperties: newProps,\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nexport default AnnotationCommands\r\n","import {\r\n  Editor,\r\n  Element,\r\n  Location,\r\n  Node,\r\n  NodeEntry,\r\n  Path,\r\n  Point,\r\n  Range,\r\n  Value,\r\n} from '../..'\r\n\r\nclass DeletingCommands {\r\n  /**\r\n   * Delete content in the editor.\r\n   */\r\n\r\n  delete(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location\r\n      distance?: number\r\n      unit?: 'character' | 'word' | 'line' | 'block'\r\n      reverse?: boolean\r\n      hanging?: boolean\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      const { reverse = false, unit = 'character', distance = 1 } = options\r\n      let { at = this.value.selection, hanging = false } = options\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\r\n        at = at.anchor\r\n      }\r\n\r\n      if (Point.isPoint(at)) {\r\n        const furthestVoid = this.getMatch(at.path, 'void')\r\n\r\n        if (furthestVoid) {\r\n          const [, voidPath] = furthestVoid\r\n          at = voidPath\r\n        } else {\r\n          const opts = { unit, distance }\r\n          const target = reverse\r\n            ? this.getBefore(at, opts) || this.getStart([])\r\n            : this.getAfter(at, opts) || this.getEnd([])\r\n          at = { anchor: at, focus: target }\r\n          hanging = true\r\n        }\r\n      }\r\n\r\n      if (Path.isPath(at)) {\r\n        this.removeNodes({ at })\r\n        return\r\n      }\r\n\r\n      if (Range.isCollapsed(at)) {\r\n        return\r\n      }\r\n\r\n      if (!hanging) {\r\n        at = this.unhangRange(at)\r\n      }\r\n\r\n      let [start, end] = Range.edges(at)\r\n      const [ancestor] = this.getAncestor(at)\r\n      const isSingleText = Path.equals(start.path, end.path)\r\n      const startVoid = this.getMatch(start.path, 'void')\r\n      const endVoid = this.getMatch(end.path, 'void')\r\n\r\n      // If the start or end points are inside an inline void, nudge them out.\r\n      if (startVoid) {\r\n        const block = this.getMatch(start.path, 'block')\r\n        const before = this.getBefore(start)\r\n\r\n        if (before && block && Path.isAncestor(block[1], before.path)) {\r\n          start = before\r\n        }\r\n      }\r\n\r\n      if (endVoid) {\r\n        const block = this.getMatch(end.path, 'block')\r\n        const after = this.getAfter(end)\r\n\r\n        if (after && block && Path.isAncestor(block[1], after.path)) {\r\n          end = after\r\n        }\r\n      }\r\n\r\n      // Get the highest nodes that are completely inside the range, as well as\r\n      // the start and end nodes.\r\n      const matches = this.matches({\r\n        at,\r\n        match: ([n, p]) =>\r\n          (Element.isElement(n) && this.isVoid(n)) ||\r\n          (!Path.isCommon(p, start.path) && !Path.isCommon(p, end.path)),\r\n      })\r\n\r\n      const pathRefs = Array.from(matches, ([, p]) => this.createPathRef(p))\r\n      const startRef = this.createPointRef(start)\r\n      const endRef = this.createPointRef(end)\r\n\r\n      if (!isSingleText && !startVoid) {\r\n        const point = startRef.current!\r\n        const [node] = this.getLeaf(point)\r\n        const { path } = point\r\n        const { offset } = start\r\n        const text = node.text.slice(offset)\r\n        this.apply({ type: 'remove_text', path, offset, text })\r\n      }\r\n\r\n      for (const pathRef of pathRefs) {\r\n        const path = pathRef.unref()!\r\n        this.removeNodes({ at: path })\r\n      }\r\n\r\n      if (!endVoid) {\r\n        const point = endRef.current!\r\n        const [node] = this.getLeaf(point)\r\n        const { path } = point\r\n        const offset = isSingleText ? start.offset : 0\r\n        const text = node.text.slice(offset, end.offset)\r\n        this.apply({ type: 'remove_text', path, offset, text })\r\n      }\r\n\r\n      const isBlockAncestor =\r\n        Value.isValue(ancestor) ||\r\n        (Element.isElement(ancestor) && !this.isInline(ancestor))\r\n\r\n      if (\r\n        !isSingleText &&\r\n        isBlockAncestor &&\r\n        endRef.current &&\r\n        startRef.current\r\n      ) {\r\n        this.mergeNodes({ at: endRef.current, hanging: true })\r\n      }\r\n\r\n      const point = endRef.unref() || startRef.unref()\r\n\r\n      if (options.at == null && point) {\r\n        this.select(point)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */\r\n\r\n  insertFragment(\r\n    this: Editor,\r\n    fragment: Node[],\r\n    options: {\r\n      at?: Location\r\n      hanging?: boolean\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      let { at = this.value.selection } = options\r\n      const { hanging = false } = options\r\n\r\n      if (!fragment.length) {\r\n        return\r\n      }\r\n\r\n      if (!at) {\r\n        return\r\n      } else if (Range.isRange(at)) {\r\n        if (!hanging) {\r\n          at = this.unhangRange(at)\r\n        }\r\n\r\n        if (Range.isCollapsed(at)) {\r\n          at = at.anchor\r\n        } else {\r\n          const [, end] = Range.edges(at)\r\n          const pointRef = this.createPointRef(end)\r\n          this.delete({ at })\r\n          at = pointRef.unref()!\r\n        }\r\n      } else if (Path.isPath(at)) {\r\n        at = this.getStart(at)\r\n      }\r\n\r\n      if (this.getMatch(at.path, 'void')) {\r\n        return\r\n      }\r\n\r\n      // If the insert point is at the edge of an inline node, move it outside\r\n      // instead since it will need to be split otherwise.\r\n      const inlineElementMatch = this.getMatch(at, 'inline-element')\r\n\r\n      if (inlineElementMatch) {\r\n        const [, inlinePath] = inlineElementMatch\r\n\r\n        if (this.isEnd(at, inlinePath)) {\r\n          const after = this.getAfter(inlinePath)!\r\n          at = after\r\n        } else if (this.isStart(at, inlinePath)) {\r\n          const before = this.getBefore(inlinePath)!\r\n          at = before\r\n        }\r\n      }\r\n\r\n      const blockMatch = this.getMatch(at, 'block')!\r\n      const [, blockPath] = blockMatch\r\n      const isBlockStart = this.isStart(at, blockPath)\r\n      const isBlockEnd = this.isEnd(at, blockPath)\r\n      const mergeStart = !isBlockStart || (isBlockStart && isBlockEnd)\r\n      const mergeEnd = !isBlockEnd\r\n      const [, firstPath] = Node.first({ children: fragment }, [])\r\n      const [, lastPath] = Node.last({ children: fragment }, [])\r\n\r\n      // TODO: convert into a proper `Nodes.matches` iterable\r\n      const matches: NodeEntry[] = []\r\n\r\n      const matcher = ([n, p]: NodeEntry) => {\r\n        if (\r\n          mergeStart &&\r\n          Path.isAncestor(p, firstPath) &&\r\n          Element.isElement(n) &&\r\n          !this.isVoid(n) &&\r\n          !this.isInline(n)\r\n        ) {\r\n          return false\r\n        }\r\n\r\n        if (\r\n          mergeEnd &&\r\n          Path.isAncestor(p, lastPath) &&\r\n          Element.isElement(n) &&\r\n          !this.isVoid(n) &&\r\n          !this.isInline(n)\r\n        ) {\r\n          return false\r\n        }\r\n\r\n        return true\r\n      }\r\n\r\n      for (const entry of Node.nodes(\r\n        { children: fragment },\r\n        { pass: matcher }\r\n      )) {\r\n        if (entry[1].length > 0 && matcher(entry)) {\r\n          matches.push(entry)\r\n        }\r\n      }\r\n\r\n      const starts = []\r\n      const middles = []\r\n      const ends = []\r\n      let starting = true\r\n      let hasBlocks = false\r\n\r\n      for (const [node] of matches) {\r\n        if (Element.isElement(node) && !this.isInline(node)) {\r\n          starting = false\r\n          hasBlocks = true\r\n          middles.push(node)\r\n        } else if (starting) {\r\n          starts.push(node)\r\n        } else {\r\n          ends.push(node)\r\n        }\r\n      }\r\n\r\n      const inlineMatch = this.getMatch(at, 'inline')!\r\n      const [, inlinePath] = inlineMatch\r\n      const isInlineStart = this.isStart(at, inlinePath)\r\n      const isInlineEnd = this.isEnd(at, inlinePath)\r\n\r\n      const middleRef = this.createPathRef(\r\n        isBlockEnd ? Path.next(blockPath) : blockPath\r\n      )\r\n\r\n      const endRef = this.createPathRef(\r\n        isInlineEnd ? Path.next(inlinePath) : inlinePath\r\n      )\r\n\r\n      this.splitNodes({ at, match: hasBlocks ? 'block' : 'inline' })\r\n\r\n      const startRef = this.createPathRef(\r\n        !isInlineStart || (isInlineStart && isInlineEnd)\r\n          ? Path.next(inlinePath)\r\n          : inlinePath\r\n      )\r\n\r\n      this.insertNodes(starts, { at: startRef.current!, match: 'inline' })\r\n      this.insertNodes(middles, { at: middleRef.current!, match: 'block' })\r\n      this.insertNodes(ends, { at: endRef.current!, match: 'inline' })\r\n\r\n      if (!options.at) {\r\n        let path\r\n\r\n        if (ends.length > 0) {\r\n          path = Path.previous(endRef.current!)\r\n        } else if (middles.length > 0) {\r\n          path = Path.previous(middleRef.current!)\r\n        } else {\r\n          path = Path.previous(startRef.current!)\r\n        }\r\n\r\n        const end = this.getEnd(path)\r\n        this.select(end)\r\n      }\r\n\r\n      startRef.unref()\r\n      middleRef.unref()\r\n      endRef.unref()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Insert a string of text in the editor.\r\n   */\r\n\r\n  insertText(\r\n    this: Editor,\r\n    text: string,\r\n    options: {\r\n      at?: Point | Range\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      const { selection } = this.value\r\n      let { at } = options\r\n\r\n      if (!at && selection) {\r\n        at = selection\r\n      }\r\n\r\n      if (Range.isRange(at)) {\r\n        if (Range.isCollapsed(at)) {\r\n          at = at.anchor\r\n        } else {\r\n          const pointRef = this.createPointRef(Range.end(at))\r\n          this.delete({ at })\r\n          at = pointRef.unref()!\r\n        }\r\n      }\r\n\r\n      if (Point.isPoint(at) && !this.getMatch(at.path, 'void')) {\r\n        const { path, offset } = at\r\n        this.apply({ type: 'insert_text', path, offset, text })\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Remove a string of text in the editor.\r\n   */\r\n\r\n  removeText(\r\n    this: Editor,\r\n    text: string,\r\n    options: {\r\n      at?: Range\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      const { at = this.value.selection } = options\r\n\r\n      if (!at || Range.isCollapsed(at)) {\r\n        return\r\n      }\r\n\r\n      const [start, end] = Range.edges(at)\r\n      const texts = this.texts({ at })\r\n      const pathRefs = Array.from(texts, ([, p]) => this.createPathRef(p))\r\n\r\n      for (const [node, path] of this.texts({ at }))\r\n        if (Point.isPoint(at) && !this.getMatch(at.path, 'void')) {\r\n          const { path, offset } = at\r\n          this.apply({ type: 'insert_text', path, offset, text })\r\n        }\r\n    })\r\n  }\r\n}\r\n\r\nexport default DeletingCommands\r\n","import {\r\n  Descendant,\r\n  Editor,\r\n  Node,\r\n  NodeEntry,\r\n  NodeMatch,\r\n  Element,\r\n  Location,\r\n  Path,\r\n  Text,\r\n  Range,\r\n  Point,\r\n} from '../..'\r\nimport { Value } from '../../interfaces/value'\r\n\r\nclass NodeCommands {\r\n  /**\r\n   * Insert nodes at a specific location in the editor.\r\n   */\r\n\r\n  insertNodes(\r\n    this: Editor,\r\n    nodes: Node | Node[],\r\n    options: {\r\n      at?: Location\r\n      match?: NodeMatch\r\n      hanging?: boolean\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      const { selection, hanging = false } = this.value\r\n      let { at, match } = options\r\n      let select = false\r\n\r\n      if (Node.isNode(nodes)) {\r\n        nodes = [nodes]\r\n      }\r\n\r\n      if (nodes.length === 0) {\r\n        return\r\n      }\r\n\r\n      const [node] = nodes\r\n\r\n      if (match == null) {\r\n        if (Path.isPath(at)) {\r\n          const path = at\r\n          match = ([, p]) => Path.equals(p, path)\r\n        } else if (Text.isText(node)) {\r\n          match = 'text'\r\n        } else if (this.isInline(node)) {\r\n          match = 'inline'\r\n        } else {\r\n          match = 'block'\r\n        }\r\n      }\r\n\r\n      // By default, use the selection as the target location. But if there is\r\n      // no selection, insert at the end of the document since that is such a\r\n      // common use case when inserting from a non-selected state.\r\n      if (!at) {\r\n        at = selection || this.getEnd([]) || [this.value.children.length]\r\n        select = true\r\n      }\r\n\r\n      if (Range.isRange(at)) {\r\n        if (!hanging) {\r\n          at = this.unhangRange(at)\r\n        }\r\n\r\n        if (Range.isCollapsed(at)) {\r\n          at = at.anchor\r\n        } else {\r\n          const [, end] = Range.edges(at)\r\n          const pointRef = this.createPointRef(end)\r\n          this.delete({ at })\r\n          at = pointRef.unref()!\r\n        }\r\n      }\r\n\r\n      if (Point.isPoint(at)) {\r\n        const atMatch = this.getMatch(at.path, match)\r\n\r\n        if (atMatch) {\r\n          const [, matchPath] = atMatch\r\n          const pathRef = this.createPathRef(matchPath)\r\n          const isAtEnd = this.isEnd(at, matchPath)\r\n          this.splitNodes({ at, match })\r\n          const path = pathRef.unref()!\r\n          at = isAtEnd ? Path.next(path) : path\r\n        } else {\r\n          return\r\n        }\r\n      }\r\n\r\n      const parentPath = Path.parent(at)\r\n      let index = at[at.length - 1]\r\n\r\n      if (this.getMatch(parentPath, 'void')) {\r\n        return\r\n      }\r\n\r\n      for (const node of nodes) {\r\n        const path = parentPath.concat(index)\r\n        index++\r\n        this.apply({ type: 'insert_node', path, node })\r\n      }\r\n\r\n      if (select) {\r\n        const point = this.getEnd(at)\r\n\r\n        if (point) {\r\n          this.select(point)\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */\r\n\r\n  liftNodes(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: NodeMatch\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      const { at = this.value.selection } = options\r\n      let { match } = options\r\n\r\n      if (match == null) {\r\n        if (Path.isPath(at)) {\r\n          const path = at\r\n          match = ([, p]) => Path.equals(p, path)\r\n        } else {\r\n          match = 'block'\r\n        }\r\n      }\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      const matches = this.matches({ at, match })\r\n      const pathRefs = Array.from(matches, ([, p]) => this.createPathRef(p))\r\n\r\n      for (const pathRef of pathRefs) {\r\n        const path = pathRef.unref()!\r\n\r\n        if (path.length < 2) {\r\n          throw new Error(\r\n            `Cannot lift node at a path [${path}] because it has a depth of less than \\`2\\`.`\r\n          )\r\n        }\r\n\r\n        const [parent, parentPath] = this.getNode(Path.parent(path))\r\n        const index = path[path.length - 1]\r\n        const { length } = parent.children\r\n\r\n        if (length === 1) {\r\n          this.moveNodes({ at: path, to: Path.next(parentPath) })\r\n          this.removeNodes({ at: parentPath })\r\n        } else if (index === 0) {\r\n          this.moveNodes({ at: path, to: parentPath })\r\n        } else if (index === length - 1) {\r\n          this.moveNodes({ at: path, to: Path.next(parentPath) })\r\n        } else {\r\n          this.splitNodes({ at: Path.next(path) })\r\n          this.moveNodes({ at: path, to: Path.next(parentPath) })\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */\r\n\r\n  mergeNodes(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: NodeMatch\r\n      hanging?: boolean\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      let { match, at = this.value.selection } = options\r\n      const { hanging = false } = options\r\n\r\n      if (match == null) {\r\n        if (Path.isPath(at)) {\r\n          const path = at\r\n          match = ([, p]) => Path.equals(p, path)\r\n        } else {\r\n          match = 'block'\r\n        }\r\n      }\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      if (!hanging && Range.isRange(at)) {\r\n        at = this.unhangRange(at)\r\n      }\r\n\r\n      if (Range.isRange(at)) {\r\n        if (Range.isCollapsed(at)) {\r\n          at = at.anchor\r\n        } else {\r\n          const [, end] = Range.edges(at)\r\n          const pointRef = this.createPointRef(end)\r\n          this.delete({ at })\r\n          at = pointRef.unref()!\r\n\r\n          if (options.at == null) {\r\n            this.select(at)\r\n          }\r\n        }\r\n      }\r\n\r\n      const current = this.getMatch(at, match)\r\n\r\n      if (!current) {\r\n        return\r\n      }\r\n\r\n      let prevMatch: NodeMatch = 'block'\r\n      const [node, path] = current\r\n\r\n      if (Value.isValue(node)) {\r\n        return\r\n      } else if (Text.isText(node)) {\r\n        prevMatch = 'text'\r\n      } else if (this.isInline(node)) {\r\n        prevMatch = 'inline'\r\n      }\r\n\r\n      const prev = this.getPrevious(at, prevMatch)\r\n\r\n      if (!prev) {\r\n        return\r\n      }\r\n\r\n      const [prevNode, prevPath] = prev\r\n      const newPath = Path.next(prevPath)\r\n      const commonPath = Path.common(path, prevPath)\r\n      const isPreviousSibling = Path.isSibling(path, prevPath)\r\n\r\n      // Determine if the merge will leave an ancestor of the path empty as a\r\n      // result, in which case we'll want to remove it after merging.\r\n      const emptyAncestor = Node.furthest(this.value, path, ([n, p]) => {\r\n        return (\r\n          Path.isDescendant(p, commonPath) &&\r\n          Path.isAncestor(p, path) &&\r\n          Element.isElement(n) &&\r\n          n.children.length === 1\r\n        )\r\n      })\r\n\r\n      const emptyRef = emptyAncestor && this.createPathRef(emptyAncestor[1])\r\n      let properties\r\n      let position\r\n\r\n      // Ensure that the nodes are equivalent, and figure out what the position\r\n      // and extra properties of the merge will be.\r\n      if (Text.isText(node) && Text.isText(prevNode)) {\r\n        const { text, marks, ...rest } = node\r\n        position = prevNode.text.length\r\n        properties = rest as Partial<Text>\r\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\r\n        const { children, ...rest } = node\r\n        position = prevNode.children.length\r\n        properties = rest as Partial<Element>\r\n      } else {\r\n        throw new Error(\r\n          `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\r\n            node\r\n          )} ${JSON.stringify(prevNode)}`\r\n        )\r\n      }\r\n\r\n      // If the node isn't already the next sibling of the previous node, move\r\n      // it so that it is before merging.\r\n      if (!isPreviousSibling) {\r\n        this.moveNodes({ at: path, to: newPath })\r\n      }\r\n\r\n      // If there was going to be an empty ancestor of the node that was merged,\r\n      // we remove it from the tree.\r\n      if (emptyRef) {\r\n        this.removeNodes({ at: emptyRef.current! })\r\n      }\r\n\r\n      // If the target node that we're merging with is empty, remove it instead\r\n      // of merging the two. This is a common rich text editor behavior to\r\n      // prevent losing formatting when deleting entire nodes when you have a\r\n      // hanging selection.\r\n      if (\r\n        (Element.isElement(prevNode) && this.isEmpty(prevNode)) ||\r\n        (Text.isText(prevNode) && prevNode.text === '')\r\n      ) {\r\n        this.removeNodes({ at: prevPath })\r\n      } else {\r\n        this.apply({\r\n          type: 'merge_node',\r\n          path: newPath,\r\n          position,\r\n          target: null,\r\n          properties,\r\n        })\r\n      }\r\n\r\n      if (emptyRef) {\r\n        emptyRef.unref()\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Move the nodes at a location to a new location.\r\n   */\r\n\r\n  moveNodes(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: NodeMatch\r\n      to: Path\r\n    }\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      const { to, at = this.value.selection } = options\r\n      let { match } = options\r\n\r\n      if (match == null) {\r\n        if (Path.isPath(at)) {\r\n          const path = at\r\n          match = ([, p]) => Path.equals(p, path)\r\n        } else {\r\n          match = 'block'\r\n        }\r\n      }\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      const toRef = this.createPathRef(to)\r\n      const targets = this.matches({ at, match })\r\n      const pathRefs = Array.from(targets, ([, p]) => this.createPathRef(p))\r\n\r\n      for (const pathRef of pathRefs) {\r\n        const path = pathRef.unref()!\r\n        const newPath = toRef.current!\r\n\r\n        if (path.length !== 0) {\r\n          this.apply({ type: 'move_node', path, newPath })\r\n        }\r\n      }\r\n\r\n      toRef.unref()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Normalize a node at a path, returning it to a valid state if it is\r\n   * currently invalid.\r\n   */\r\n\r\n  normalizeNodes(this: Editor, options: { at: Path }): void {\r\n    const { at } = options\r\n    const [node] = this.getNode(at)\r\n\r\n    // There are no core normalizations for text nodes.\r\n    if (Text.isText(node)) {\r\n      return\r\n    }\r\n\r\n    // Ensure that block and inline nodes have at least one text child.\r\n    if (Element.isElement(node) && node.children.length === 0) {\r\n      const child = { text: '', marks: [] }\r\n      this.insertNodes(child, { at: at.concat(0) })\r\n      return\r\n    }\r\n\r\n    // Determine whether the node should have block or inline children.\r\n    const shouldHaveInlines = Value.isValue(node)\r\n      ? false\r\n      : Element.isElement(node) &&\r\n        (this.isInline(node) ||\r\n          node.children.length === 0 ||\r\n          Text.isText(node.children[0]) ||\r\n          this.isInline(node.children[0]))\r\n\r\n    // Since we'll be applying operations while iterating, keep track of an\r\n    // index that accounts for any added/removed nodes.\r\n    let n = 0\r\n\r\n    for (let i = 0; i < node.children.length; i++, n++) {\r\n      const child = node.children[i] as Descendant\r\n      const prev = node.children[i - 1] as Descendant\r\n      const isLast = i === node.children.length - 1\r\n      const isInlineOrText =\r\n        Text.isText(child) || (Element.isElement(child) && this.isInline(child))\r\n\r\n      // Only allow block nodes in the top-level value and parent blocks that\r\n      // only contain block nodes. Similarly, only allow inline nodes in other\r\n      // inline nodes, or parent blocks that only contain inlines and text.\r\n      if (isInlineOrText !== shouldHaveInlines) {\r\n        this.removeNodes({ at: at.concat(n) })\r\n        n--\r\n        continue\r\n      }\r\n\r\n      if (Element.isElement(child)) {\r\n        // Ensure that inline nodes are surrounded by text nodes.\r\n        if (this.isInline(child)) {\r\n          if (prev == null || !Text.isText(prev)) {\r\n            const newChild = { text: '', marks: [] }\r\n            this.insertNodes(newChild, { at: at.concat(n) })\r\n            n++\r\n            continue\r\n          }\r\n\r\n          if (isLast) {\r\n            const newChild = { text: '', marks: [] }\r\n            this.insertNodes(newChild, { at: at.concat(n + 1) })\r\n            n++\r\n            continue\r\n          }\r\n        }\r\n      } else {\r\n        // Merge adjacent text nodes that are empty or have matching marks.\r\n        if (prev != null && Text.isText(prev)) {\r\n          if (Text.matches(child, prev)) {\r\n            this.mergeNodes({ at: at.concat(n) })\r\n            n--\r\n            continue\r\n          } else if (prev.text === '') {\r\n            this.removeNodes({ at: at.concat(n - 1) })\r\n            n--\r\n            continue\r\n          } else if (isLast && child.text === '') {\r\n            this.removeNodes({ at: at.concat(n) })\r\n            n--\r\n            continue\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */\r\n\r\n  removeNodes(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: NodeMatch\r\n      hanging?: boolean\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      let { match, at = this.value.selection } = options\r\n      const { hanging = false } = options\r\n\r\n      if (match == null) {\r\n        if (Path.isPath(at)) {\r\n          const path = at\r\n          match = ([, p]) => Path.equals(p, path)\r\n        } else {\r\n          match = 'block'\r\n        }\r\n      }\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      if (!hanging && Range.isRange(at)) {\r\n        at = this.unhangRange(at)\r\n      }\r\n\r\n      const depths = this.matches({ at, match })\r\n      const pathRefs = Array.from(depths, ([, p]) => this.createPathRef(p))\r\n\r\n      for (const pathRef of pathRefs) {\r\n        const path = pathRef.unref()!\r\n        const [node] = this.getNode(path)\r\n        this.apply({ type: 'remove_node', path, node })\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Set new properties on the nodes ...\r\n   */\r\n\r\n  setNodes(\r\n    this: Editor,\r\n    props: Partial<Node>,\r\n    options: {\r\n      at?: Location\r\n      match?: NodeMatch\r\n      hanging?: boolean\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      let { match, at = this.value.selection } = options\r\n      const { hanging = false } = options\r\n\r\n      if (match == null) {\r\n        if (Path.isPath(at)) {\r\n          const path = at\r\n          match = ([, p]) => Path.equals(p, path)\r\n        } else {\r\n          match = 'block'\r\n        }\r\n      }\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      if (!hanging && Range.isRange(at)) {\r\n        at = this.unhangRange(at)\r\n      }\r\n\r\n      for (const [node, path] of this.matches({ at, match })) {\r\n        const properties: Partial<Node> = {}\r\n        const newProperties: Partial<Node> = {}\r\n\r\n        for (const k in props) {\r\n          if (\r\n            k === 'annotations' ||\r\n            k === 'marks' ||\r\n            k === 'children' ||\r\n            k === 'selection' ||\r\n            k === 'text'\r\n          ) {\r\n            continue\r\n          }\r\n\r\n          if (props[k] !== node[k]) {\r\n            properties[k] = node[k]\r\n            newProperties[k] = props[k]\r\n          }\r\n        }\r\n\r\n        if (Object.keys(newProperties).length !== 0) {\r\n          this.apply({\r\n            type: 'set_node',\r\n            path,\r\n            properties,\r\n            newProperties,\r\n          })\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Split the nodes at a specific location.\r\n   */\r\n\r\n  splitNodes(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: NodeMatch\r\n      always?: boolean\r\n      height?: number\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      let {\r\n        match,\r\n        at = this.value.selection,\r\n        height = 0,\r\n        always = false,\r\n      } = options\r\n\r\n      if (match == null) {\r\n        match = 'block'\r\n      }\r\n\r\n      if (Range.isRange(at)) {\r\n        at = deleteRange(this, at)\r\n      }\r\n\r\n      // If the target is a path, the default height-skipping and position\r\n      // counters need to account for us potentially splitting at a non-leaf.\r\n      if (Path.isPath(at)) {\r\n        const path = at\r\n        const point = this.getPoint(path)\r\n        match = ([, p]) => p.length === path.length - 1\r\n        height = point.path.length - path.length + 1\r\n        at = point\r\n        always = true\r\n      }\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      const beforeRef = this.createPointRef(at, { affinity: 'backward' })\r\n      const highest = this.getMatch(at, match)\r\n\r\n      if (!highest) {\r\n        return\r\n      }\r\n\r\n      const voidMatch = this.getMatch(at, 'void')\r\n      const nudge = 0\r\n\r\n      if (voidMatch) {\r\n        const [voidNode, voidPath] = voidMatch\r\n\r\n        if (Element.isElement(voidNode) && this.isInline(voidNode)) {\r\n          let after = this.getAfter(voidPath)\r\n\r\n          if (!after) {\r\n            const text = { text: '', marks: [] }\r\n            const afterPath = Path.next(voidPath)\r\n            this.insertNodes(text, { at: afterPath })\r\n            after = this.getPoint(afterPath)!\r\n          }\r\n\r\n          at = after\r\n          always = true\r\n        }\r\n\r\n        const siblingHeight = at.path.length - voidPath.length\r\n        height = siblingHeight + 1\r\n        always = true\r\n      }\r\n\r\n      const afterRef = this.createPointRef(at)\r\n      const depth = at.path.length - height\r\n      const [, highestPath] = highest\r\n      const lowestPath = at.path.slice(0, depth)\r\n      let position = height === 0 ? at.offset : at.path[depth] + nudge\r\n      let target: number | null = null\r\n\r\n      for (const [node, path] of this.levels({\r\n        at: lowestPath,\r\n        reverse: true,\r\n      })) {\r\n        let split = false\r\n\r\n        if (\r\n          path.length < highestPath.length ||\r\n          path.length === 0 ||\r\n          (Element.isElement(node) && this.isVoid(node))\r\n        ) {\r\n          break\r\n        }\r\n\r\n        const point = beforeRef.current!\r\n        const isEnd = this.isEnd(point, path)\r\n\r\n        if (always || !beforeRef || !this.isEdge(point, path)) {\r\n          const { text, marks, children, ...properties } = node\r\n          this.apply({ type: 'split_node', path, position, target, properties })\r\n          split = true\r\n        }\r\n\r\n        target = position\r\n        position = path[path.length - 1] + (split || isEnd ? 1 : 0)\r\n      }\r\n\r\n      if (options.at == null) {\r\n        const point = afterRef.current || this.getEnd([])\r\n        this.select(point)\r\n      }\r\n\r\n      beforeRef.unref()\r\n      afterRef.unref()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */\r\n\r\n  unwrapNodes(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location\r\n      match?: NodeMatch\r\n      split?: boolean\r\n    }\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      const { at = this.value.selection, split = false } = options\r\n      let { match } = options\r\n\r\n      if (match == null) {\r\n        if (Path.isPath(at)) {\r\n          const path = at\r\n          match = ([, p]) => Path.equals(p, path)\r\n        } else {\r\n          match = 'block'\r\n        }\r\n      }\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      const matches = this.matches({ at, match })\r\n      const pathRefs = Array.from(matches, ([, p]) => this.createPathRef(p))\r\n\r\n      for (const pathRef of pathRefs) {\r\n        const path = pathRef.unref()!\r\n        const depth = path.length + 1\r\n        let range = this.getRange(path)\r\n\r\n        if (split && Range.isRange(at)) {\r\n          range = Range.intersection(at, range)!\r\n        }\r\n\r\n        this.liftNodes({ at: range, match: ([, p]) => p.length === depth })\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */\r\n\r\n  wrapNodes(\r\n    this: Editor,\r\n    element: Element,\r\n    options: {\r\n      at?: Location\r\n      match?: NodeMatch\r\n      split?: boolean\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      const { split = false } = options\r\n      let { match, at = this.value.selection } = options\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      if (match == null) {\r\n        if (Path.isPath(at)) {\r\n          const path = at\r\n          match = ([, p]) => Path.equals(p, path)\r\n        } else if (this.isInline(element)) {\r\n          match = 'inline'\r\n        } else {\r\n          match = 'block'\r\n        }\r\n      }\r\n\r\n      if (split && Range.isRange(at)) {\r\n        const [start, end] = Range.edges(at)\r\n        const rangeRef = this.createRangeRef(at, { affinity: 'inward' })\r\n        this.splitNodes({ at: end, match })\r\n        this.splitNodes({ at: start, match })\r\n        at = rangeRef.unref()!\r\n\r\n        if (options.at == null) {\r\n          this.select(at)\r\n        }\r\n      }\r\n\r\n      const roots: NodeEntry[] = this.isInline(element)\r\n        ? Array.from(this.matches({ ...options, at, match: 'block' }))\r\n        : [[this.value, []]]\r\n\r\n      for (const [, rootPath] of roots) {\r\n        const a = Range.isRange(at)\r\n          ? Range.intersection(at, this.getRange(rootPath))\r\n          : at\r\n\r\n        if (!a) {\r\n          continue\r\n        }\r\n\r\n        const matches = Array.from(this.matches({ ...options, at: a, match }))\r\n\r\n        if (matches.length > 0) {\r\n          const [first] = matches\r\n          const last = matches[matches.length - 1]\r\n          const [, firstPath] = first\r\n          const [, lastPath] = last\r\n          const commonPath = Path.equals(firstPath, lastPath)\r\n            ? Path.parent(firstPath)\r\n            : Path.common(firstPath, lastPath)\r\n\r\n          const range = this.getRange(firstPath, lastPath)\r\n          const depth = commonPath.length + 1\r\n          const wrapperPath = Path.next(lastPath).slice(0, depth)\r\n          const wrapper = { ...element, children: [] }\r\n          this.insertNodes(wrapper, { at: wrapperPath })\r\n\r\n          this.moveNodes({\r\n            at: range,\r\n            match: ([, p]) => p.length === depth,\r\n            to: wrapperPath.concat(0),\r\n          })\r\n        }\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\r\n\r\nconst deleteRange = (editor: Editor, range: Range): Point | null => {\r\n  if (Range.isCollapsed(range)) {\r\n    return range.anchor\r\n  } else {\r\n    const [, end] = Range.edges(range)\r\n    const pointRef = editor.createPointRef(end)\r\n    editor.delete({ at: range })\r\n    return pointRef.unref()\r\n  }\r\n}\r\n\r\nexport default NodeCommands\r\n","import { Editor, Mark, Location, Range } from '../..'\r\n\r\nclass MarkCommands {\r\n  /**\r\n   * Add a set of marks to the text nodes at a location.\r\n   */\r\n\r\n  addMarks(\r\n    this: Editor,\r\n    marks: Mark[],\r\n    options: {\r\n      at?: Location\r\n      hanging?: boolean\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      const at = splitLocation(this, options)\r\n\r\n      if (!at) {\r\n        return\r\n      }\r\n\r\n      // De-dupe the marks being added to ensure the set is unique.\r\n      const set: Mark[] = []\r\n\r\n      for (const mark of marks) {\r\n        if (!Mark.exists(mark, set)) {\r\n          set.push(mark)\r\n        }\r\n      }\r\n\r\n      for (const [node, path] of this.texts({ at })) {\r\n        for (const mark of set) {\r\n          if (!Mark.exists(mark, node.marks)) {\r\n            this.apply({ type: 'add_mark', path, mark })\r\n          }\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  removeMarks(\r\n    this: Editor,\r\n    marks: Mark[],\r\n    options: {\r\n      at?: Location\r\n      hanging?: boolean\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      const at = splitLocation(this, options)\r\n\r\n      if (at) {\r\n        for (const [mark, i, node, path] of this.marks({ at })) {\r\n          if (Mark.exists(mark, marks)) {\r\n            this.apply({ type: 'remove_mark', path, mark })\r\n          }\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  setMarks(\r\n    this: Editor,\r\n    marks: Mark[],\r\n    props: Partial<Mark>,\r\n    options: {\r\n      at?: Location\r\n      hanging?: boolean\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      const at = splitLocation(this, options)\r\n\r\n      if (at) {\r\n        for (const [mark, i, node, path] of this.marks({ at })) {\r\n          if (Mark.exists(mark, marks)) {\r\n            const newProps = {}\r\n\r\n            for (const k in props) {\r\n              if (props[k] !== mark[k]) {\r\n                newProps[k] = props[k]\r\n              }\r\n            }\r\n\r\n            if (Object.keys(newProps).length > 0) {\r\n              this.apply({\r\n                type: 'set_mark',\r\n                path,\r\n                properties: mark,\r\n                newProperties: newProps,\r\n              })\r\n            }\r\n          }\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  toggleMarks(\r\n    this: Editor,\r\n    marks: Mark[],\r\n    options: {\r\n      at?: Location\r\n      hanging?: boolean\r\n    } = {}\r\n  ) {\r\n    this.withoutNormalizing(() => {\r\n      const existing = this.getActiveMarks(options)\r\n      const exists = marks.every(m => Mark.exists(m, existing))\r\n\r\n      if (exists) {\r\n        this.removeMarks(marks, options)\r\n      } else {\r\n        this.addMarks(marks, options)\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Split the text nodes at a range's edges to prepare for adding/removing marks.\r\n */\r\n\r\nconst splitLocation = (\r\n  editor: Editor,\r\n  options: {\r\n    at?: Location\r\n    hanging?: boolean\r\n  } = {}\r\n): Location | undefined => {\r\n  let { at = editor.value.selection, hanging = false } = options\r\n\r\n  if (!at) {\r\n    return\r\n  }\r\n\r\n  if (Range.isRange(at)) {\r\n    if (!hanging) {\r\n      at = editor.unhangRange(at)\r\n    }\r\n\r\n    const rangeRef = editor.createRangeRef(at, { affinity: 'inward' })\r\n    const [start, end] = Range.edges(at)\r\n    editor.splitNodes({ at: end, match: 'text' })\r\n    editor.splitNodes({ at: start, match: 'text' })\r\n    const range = rangeRef.unref()!\r\n\r\n    if (options.at == null) {\r\n      editor.select(range)\r\n    }\r\n\r\n    return range\r\n  }\r\n\r\n  return at\r\n}\r\n\r\nexport default MarkCommands\r\n","import { Editor, Location, Point, Range, Path } from '../..'\r\n\r\nclass SelectionCommands {\r\n  /**\r\n   * Collapse the selection.\r\n   */\r\n\r\n  collapse(\r\n    this: Editor,\r\n    options: {\r\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\r\n    } = {}\r\n  ) {\r\n    const { edge = 'anchor' } = options\r\n    const { selection } = this.value\r\n\r\n    if (!selection) {\r\n      return\r\n    } else if (edge === 'anchor') {\r\n      this.select(selection.anchor)\r\n    } else if (edge === 'focus') {\r\n      this.select(selection.focus)\r\n    } else if (edge === 'start') {\r\n      const [start] = Range.edges(selection)\r\n      this.select(start)\r\n    } else if (edge === 'end') {\r\n      const [, end] = Range.edges(selection)\r\n      this.select(end)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unset the selection.\r\n   */\r\n\r\n  deselect(this: Editor) {\r\n    const { selection } = this.value\r\n\r\n    if (selection) {\r\n      this.apply({\r\n        type: 'set_selection',\r\n        properties: selection,\r\n        newProperties: null,\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move the selection's point forward or backward.\r\n   */\r\n\r\n  move(\r\n    this: Editor,\r\n    options: {\r\n      distance?: number\r\n      unit?: 'offset' | 'character' | 'word' | 'line'\r\n      reverse?: boolean\r\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\r\n    } = {}\r\n  ) {\r\n    const { selection } = this.value\r\n    const { distance = 1, unit = 'character', reverse = false } = options\r\n    let { edge = null } = options\r\n\r\n    if (!selection) {\r\n      return\r\n    }\r\n\r\n    if (edge === 'start') {\r\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\r\n    }\r\n\r\n    if (edge === 'end') {\r\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\r\n    }\r\n\r\n    const { anchor, focus } = selection\r\n    const opts = { distance, unit }\r\n    const props: Partial<Range> = {}\r\n\r\n    if (edge == null || edge === 'anchor') {\r\n      const point = reverse\r\n        ? this.getBefore(anchor, opts)\r\n        : this.getAfter(anchor, opts)\r\n\r\n      if (point) {\r\n        props.anchor = point\r\n      }\r\n    }\r\n\r\n    if (edge == null || edge === 'focus') {\r\n      const point = reverse\r\n        ? this.getBefore(focus, opts)\r\n        : this.getAfter(focus, opts)\r\n\r\n      if (point) {\r\n        props.focus = point\r\n      }\r\n    }\r\n\r\n    this.setSelection(props)\r\n  }\r\n\r\n  /**\r\n   * Set the selection to a new value.\r\n   */\r\n\r\n  select(this: Editor, target: Location) {\r\n    const { selection } = this.value\r\n    target = this.getRange(target)\r\n\r\n    if (selection) {\r\n      this.setSelection(target)\r\n      return\r\n    }\r\n\r\n    if (!Range.isRange(target)) {\r\n      throw new Error(\r\n        `When setting the selection and the current selection is \\`null\\` you must provide at least an \\`anchor\\` and \\`focus\\`, but you passed: ${JSON.stringify(\r\n          target\r\n        )}`\r\n      )\r\n    }\r\n\r\n    this.apply({\r\n      type: 'set_selection',\r\n      properties: selection,\r\n      newProperties: target,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Set new properties on one of the selection's points.\r\n   */\r\n\r\n  setPoint(\r\n    this: Editor,\r\n    props: Partial<Point>,\r\n    options: {\r\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\r\n    }\r\n  ) {\r\n    const { selection } = this.value\r\n    let { edge = 'both' } = options\r\n\r\n    if (!selection) {\r\n      return\r\n    }\r\n\r\n    if (edge === 'start') {\r\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\r\n    }\r\n\r\n    if (edge === 'end') {\r\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\r\n    }\r\n\r\n    const { anchor, focus } = selection\r\n    const point = edge === 'anchor' ? anchor : focus\r\n    const newPoint = Object.assign(point, props)\r\n\r\n    if (edge === 'anchor') {\r\n      this.setSelection({ anchor: newPoint })\r\n    } else {\r\n      this.setSelection({ focus: newPoint })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set new properties on the selection.\r\n   */\r\n\r\n  setSelection(this: Editor, props: Partial<Range>) {\r\n    const { selection } = this.value\r\n    const oldProps: Partial<Range> | null = {}\r\n    const newProps: Partial<Range> = {}\r\n\r\n    if (!selection) {\r\n      return\r\n    }\r\n\r\n    for (const k in props) {\r\n      if (\r\n        (k === 'anchor' &&\r\n          props.anchor != null &&\r\n          !Point.equals(props.anchor, selection.anchor)) ||\r\n        (k === 'focus' &&\r\n          props.focus != null &&\r\n          !Point.equals(props.focus, selection.focus)) ||\r\n        (k !== 'anchor' && k !== 'focus' && props[k] !== selection[k])\r\n      ) {\r\n        oldProps[k] = selection[k]\r\n        newProps[k] = props[k]\r\n      }\r\n    }\r\n\r\n    if (Object.keys(oldProps).length > 0) {\r\n      this.apply({\r\n        type: 'set_selection',\r\n        properties: oldProps,\r\n        newProperties: newProps,\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nexport default SelectionCommands\r\n","import { Operation, Editor, Node, Path, Text, Value } from '../..'\r\nimport {\r\n  DIRTY_PATHS,\r\n  PATH_REFS,\r\n  POINT_REFS,\r\n  RANGE_REFS,\r\n  FLUSHING,\r\n  NORMALIZING,\r\n} from '../../utils/state'\r\n\r\nclass GeneralCommands {\r\n  apply(this: Editor, op: Operation): void {\r\n    for (const ref of PATH_REFS.get(this)!) {\r\n      ref.transform(op)\r\n    }\r\n\r\n    for (const ref of POINT_REFS.get(this)!) {\r\n      ref.transform(op)\r\n    }\r\n\r\n    for (const ref of RANGE_REFS.get(this)!) {\r\n      ref.transform(op)\r\n    }\r\n\r\n    const set = new Set()\r\n    const dirtyPaths: Path[] = []\r\n\r\n    const add = (path: Path | null) => {\r\n      if (path) {\r\n        const key = path.join(',')\r\n\r\n        if (!set.has(key)) {\r\n          set.add(key)\r\n          dirtyPaths.push(path)\r\n        }\r\n      }\r\n    }\r\n\r\n    const oldDirtyPaths = DIRTY_PATHS.get(this)!\r\n    const newDirtyPaths = getDirtyPaths(op)\r\n\r\n    for (const path of oldDirtyPaths) {\r\n      const newPath = Path.transform(path, op)\r\n      add(newPath)\r\n    }\r\n\r\n    for (const path of newDirtyPaths) {\r\n      add(path)\r\n    }\r\n\r\n    DIRTY_PATHS.set(this, dirtyPaths)\r\n    this.value = Value.transform(this.value, op)\r\n    this.operations.push(op)\r\n    this.normalize()\r\n\r\n    if (!FLUSHING.get(this)) {\r\n      FLUSHING.set(this, true)\r\n      Promise.resolve().then(() => this.flush())\r\n    }\r\n  }\r\n\r\n  flush(this: Editor): void {\r\n    FLUSHING.set(this, false)\r\n    const { value, operations } = this\r\n\r\n    if (operations.length !== 0) {\r\n      this.operations = []\r\n      this.onChange(value, operations)\r\n    }\r\n  }\r\n\r\n  normalize(\r\n    this: Editor,\r\n    options: {\r\n      force?: boolean\r\n    } = {}\r\n  ): void {\r\n    const { force = false } = options\r\n\r\n    if (!NORMALIZING.get(this)) {\r\n      return\r\n    }\r\n\r\n    if (force) {\r\n      const allPaths = Array.from(Node.nodes(this.value), ([, p]) => p)\r\n      DIRTY_PATHS.set(this, allPaths)\r\n    }\r\n\r\n    if (DIRTY_PATHS.get(this)!.length === 0) {\r\n      return\r\n    }\r\n\r\n    this.withoutNormalizing(() => {\r\n      const max = DIRTY_PATHS.get(this)!.length * 42 // HACK: better way to do this?\r\n      let m = 0\r\n\r\n      while (DIRTY_PATHS.get(this)!.length !== 0) {\r\n        if (m > max) {\r\n          throw new Error(`\r\n            Could not completely normalize the value after ${max} iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\r\n          `)\r\n        }\r\n\r\n        const path = DIRTY_PATHS.get(this)!.pop()\r\n        this.normalizeNodes({ at: path! })\r\n        m++\r\n      }\r\n    })\r\n  }\r\n\r\n  withoutNormalizing(this: Editor, fn: () => void): void {\r\n    const value = NORMALIZING.get(this)!\r\n    NORMALIZING.set(this, false)\r\n    fn()\r\n    NORMALIZING.set(this, value)\r\n    this.normalize()\r\n  }\r\n}\r\n\r\n/**\r\n * Get the \"dirty\" paths generated from an operation.\r\n */\r\n\r\nconst getDirtyPaths = (op: Operation) => {\r\n  switch (op.type) {\r\n    case 'add_mark':\r\n    case 'insert_text':\r\n    case 'remove_mark':\r\n    case 'remove_text':\r\n    case 'set_mark':\r\n    case 'set_node': {\r\n      const { path } = op\r\n      return Path.levels(path)\r\n    }\r\n\r\n    case 'insert_node': {\r\n      const { node, path } = op\r\n      const levels = Path.levels(path)\r\n      const descendants = Text.isText(node)\r\n        ? []\r\n        : Array.from(Node.nodes(node), ([, p]) => path.concat(p))\r\n\r\n      return [...levels, ...descendants]\r\n    }\r\n\r\n    case 'merge_node': {\r\n      const { path } = op\r\n      const ancestors = Path.ancestors(path)\r\n      const previousPath = Path.previous(path)\r\n      return [...ancestors, previousPath]\r\n    }\r\n\r\n    case 'move_node': {\r\n      const { path, newPath } = op\r\n\r\n      if (Path.equals(path, newPath)) {\r\n        return []\r\n      }\r\n\r\n      const oldAncestors: Path[] = []\r\n      const newAncestors: Path[] = []\r\n\r\n      for (const ancestor of Path.ancestors(path)) {\r\n        const p = Path.transform(ancestor, op)\r\n        oldAncestors.push(p!)\r\n      }\r\n\r\n      for (const ancestor of Path.ancestors(newPath)) {\r\n        const p = Path.transform(ancestor, op)\r\n        newAncestors.push(p!)\r\n      }\r\n\r\n      return [...oldAncestors, ...newAncestors]\r\n    }\r\n\r\n    case 'remove_node': {\r\n      const { path } = op\r\n      const ancestors = Path.ancestors(path)\r\n      return [...ancestors]\r\n    }\r\n\r\n    case 'split_node': {\r\n      const { path } = op\r\n      const levels = Path.levels(path)\r\n      const nextPath = Path.next(path)\r\n      return [...levels, nextPath]\r\n    }\r\n\r\n    default: {\r\n      return []\r\n    }\r\n  }\r\n}\r\n\r\nexport default GeneralCommands\r\n","import { Editor, Element, Text } from '../..'\r\n\r\nclass ElementQueries {\r\n  /**\r\n   * Check if a node has block children.\r\n   */\r\n\r\n  hasBlocks(this: Editor, element: Element): boolean {\r\n    return element.children.some(n => Element.isElement(n) && !this.isInline(n))\r\n  }\r\n\r\n  /**\r\n   * Check if a node has inline and text children.\r\n   */\r\n\r\n  hasInlines(this: Editor, element: Element): boolean {\r\n    return element.children.some(\r\n      n => Text.isText(n) || (Element.isElement(n) && this.isInline(n))\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if a node has text children.\r\n   */\r\n\r\n  hasTexts(this: Editor, element: Element): boolean {\r\n    return element.children.every(n => Text.isText(n))\r\n  }\r\n\r\n  /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */\r\n\r\n  isEmpty(this: Editor, element: Element): boolean {\r\n    const { children } = element\r\n    const [first] = children\r\n    return (\r\n      children.length === 0 ||\r\n      (children.length === 1 &&\r\n        Text.isText(first) &&\r\n        first.text === '' &&\r\n        !this.isVoid(element))\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Check if a node is an inline, meaning that it lives intermixed with text\r\n   * nodes in the document tree.\r\n   */\r\n\r\n  isInline(this: Editor, element: Element): boolean {\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Check if a node is a void, meaning that Slate considers its content a black\r\n   * box. It will be edited as if it has no content.\r\n   */\r\n\r\n  isVoid(this: Editor, element: Element): boolean {\r\n    return false\r\n  }\r\n}\r\n\r\nexport default ElementQueries\r\n","import { Editor, Path, Point, PathRef, PointRef, Range, RangeRef } from '../..'\r\n\r\nclass GeneralQueries {\r\n  /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the this.\r\n   */\r\n\r\n  createPathRef(\r\n    this: Editor,\r\n    path: Path,\r\n    options: { affinity?: 'backward' | 'forward' | null } = {}\r\n  ): PathRef {\r\n    const { affinity = 'forward' } = options\r\n    const ref: PathRef = new PathRef({ path, affinity, editor: this })\r\n    return ref\r\n  }\r\n\r\n  /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the this.\r\n   */\r\n\r\n  createPointRef(\r\n    this: Editor,\r\n    point: Point,\r\n    options: { affinity?: 'backward' | 'forward' | null } = {}\r\n  ): PointRef {\r\n    const { affinity = 'forward' } = options\r\n    const ref: PointRef = new PointRef({ point, affinity, editor: this })\r\n    return ref\r\n  }\r\n\r\n  /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the this.\r\n   */\r\n\r\n  createRangeRef(\r\n    this: Editor,\r\n    range: Range,\r\n    options: {\r\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\r\n    } = {}\r\n  ): RangeRef {\r\n    const { affinity = 'forward' } = options\r\n    const ref: RangeRef = new RangeRef({ range, affinity, editor: this })\r\n    return ref\r\n  }\r\n}\r\n\r\nexport default GeneralQueries\r\n","/**\r\n * Constants for string distance checking.\r\n */\r\n\r\nconst SPACE = /\\s/\r\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\r\nconst CHAMELEON = /['\\u2018\\u2019]/\r\nconst SURROGATE_START = 0xd800\r\nconst SURROGATE_END = 0xdfff\r\n\r\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\r\n\r\nexport const isWordCharacter = (char: string, remaining: string): boolean => {\r\n  if (SPACE.test(char)) {\r\n    return false\r\n  }\r\n\r\n  // Chameleons count as word characters as long as they're in a word, so\r\n  // recurse to see if the next one is a word character or not.\r\n  if (CHAMELEON.test(char)) {\r\n    let next = remaining.charAt(0)\r\n    const length = getCharacterDistance(next)\r\n    next = remaining.slice(0, length)\r\n    const rest = remaining.slice(length)\r\n\r\n    if (isWordCharacter(next, rest)) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  if (PUNCTUATION.test(char)) {\r\n    return false\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\r\n\r\nexport const getCharacterDistance = (text: string): number => {\r\n  const code = text.charCodeAt(0)\r\n  const isSurrogate = SURROGATE_START <= code && code <= SURROGATE_END\r\n  return isSurrogate ? 2 : 1\r\n}\r\n\r\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\r\n\r\nexport const getWordDistance = (text: string): number => {\r\n  let length = 0\r\n  let i = 0\r\n  let started = false\r\n  let char\r\n\r\n  while ((char = text.charAt(i))) {\r\n    const l = getCharacterDistance(char)\r\n    char = text.slice(i, i + l)\r\n    const rest = text.slice(i + l)\r\n\r\n    if (isWordCharacter(char, rest)) {\r\n      started = true\r\n      length += l\r\n    } else if (!started) {\r\n      length += l\r\n    } else {\r\n      break\r\n    }\r\n\r\n    i += l\r\n  }\r\n\r\n  return length\r\n}\r\n","import { reverse as reverseText } from 'esrever'\r\n\r\nimport { getCharacterDistance, getWordDistance } from '../../utils/strings'\r\nimport {\r\n  Ancestor,\r\n  AncestorEntry,\r\n  AnnotationEntry,\r\n  Editor,\r\n  Element,\r\n  ElementEntry,\r\n  Location,\r\n  Mark,\r\n  MarkEntry,\r\n  Node,\r\n  NodeEntry,\r\n  NodeMatch,\r\n  Path,\r\n  Point,\r\n  Range,\r\n  Span,\r\n  Text,\r\n  TextEntry,\r\n} from '../..'\r\nimport { Descendant } from '../../interfaces/node'\r\n\r\nclass LocationQueries {\r\n  /**\r\n   * Iterate through all of the annotations in the editor.\r\n   */\r\n\r\n  *annotations(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location\r\n    } = {}\r\n  ): Iterable<AnnotationEntry> {\r\n    const { annotations, selection } = this.value\r\n    const { at = selection } = options\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    const range = this.getRange(at)\r\n\r\n    for (const key in annotations) {\r\n      const annotation = annotations[key]\r\n\r\n      if (at && !Range.includes(range, annotation)) {\r\n        continue\r\n      }\r\n\r\n      yield [annotation, key]\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iterate through all of the elements in the editor.\r\n   */\r\n\r\n  *elements(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location | Span\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Iterable<ElementEntry> {\r\n    const { at = this.value.selection } = options\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    const [from, to] = getSpan(this, at, options)\r\n\r\n    yield* Node.elements(this.value, {\r\n      ...options,\r\n      from,\r\n      to,\r\n      pass: ([n]) => Element.isElement(n) && this.isVoid(n),\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Get the marks that are \"active\" at a location. These are the\r\n   * marks that will be added to any text that is inserted.\r\n   *\r\n   * The `union: true` option can be passed to create a union of marks across\r\n   * the text nodes in the selection, instead of creating an intersection, which\r\n   * is the default.\r\n   *\r\n   * Note: to obey common rich text behavior, if the selection is collapsed at\r\n   * the start of a text node and there are previous text nodes in the same\r\n   * block, it will carry those marks forward from the previous text node. This\r\n   * allows for continuation of marks from previous words.\r\n   */\r\n\r\n  getActiveMarks(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location\r\n      union?: boolean\r\n      hanging?: boolean\r\n    } = {}\r\n  ): Mark[] {\r\n    const { union = false, hanging = false } = options\r\n    let { at = this.value.selection } = options\r\n\r\n    if (!at) {\r\n      return []\r\n    }\r\n\r\n    at = this.getRange(at)\r\n\r\n    if (!hanging) {\r\n      at = this.unhangRange(at)\r\n    }\r\n\r\n    // If the range is collapsed at the start of a text node, it should carry\r\n    // over the marks from the previous text node in the same block.\r\n    if (Range.isCollapsed(at) && at.anchor.offset === 0) {\r\n      const { anchor } = at\r\n      const prev = this.getPrevious(anchor, 'text')\r\n\r\n      if (prev && Path.isSibling(anchor.path, prev[1])) {\r\n        const [prevNode, prevPath] = prev\r\n\r\n        if (Text.isText(prevNode)) {\r\n          at = this.getRange(prevPath)\r\n        }\r\n      }\r\n    }\r\n\r\n    const marks: Mark[] = []\r\n    let first = true\r\n\r\n    for (const [node] of this.texts({ at })) {\r\n      if (first) {\r\n        marks.push(...node.marks)\r\n        first = false\r\n        continue\r\n      }\r\n\r\n      if (union) {\r\n        for (const mark of node.marks) {\r\n          if (!Mark.exists(mark, marks)) {\r\n            marks.push(mark)\r\n          }\r\n        }\r\n      } else {\r\n        // PERF: If we're doing an intersection and the result hits zero it can\r\n        // never increase again, so we can exit early.\r\n        if (marks.length === 0) {\r\n          break\r\n        }\r\n\r\n        // Iterate backwards so that removing marks doesn't impact indexing.\r\n        for (let i = marks.length - 1; i >= 0; i--) {\r\n          const existing = marks[i]\r\n\r\n          if (!Mark.exists(existing, node.marks)) {\r\n            marks.splice(i, 1)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return marks\r\n  }\r\n\r\n  /**\r\n   * Get the point after a location.\r\n   */\r\n\r\n  getAfter(\r\n    this: Editor,\r\n    at: Location,\r\n    options: {\r\n      distance?: number\r\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\r\n    } = {}\r\n  ): Point | undefined {\r\n    const anchor = this.getPoint(at, { edge: 'end' })\r\n    const focus = this.getEnd([])\r\n    const range = { anchor, focus }\r\n    const { distance = 1 } = options\r\n    let d = 0\r\n    let target\r\n\r\n    for (const p of this.positions({ ...options, at: range })) {\r\n      if (d > distance) {\r\n        break\r\n      }\r\n\r\n      if (d !== 0) {\r\n        target = p\r\n      }\r\n\r\n      d++\r\n    }\r\n\r\n    return target\r\n  }\r\n\r\n  /**\r\n   * Get the common ancestor node of a location.\r\n   */\r\n\r\n  getAncestor(\r\n    this: Editor,\r\n    at: Location,\r\n    options: {\r\n      depth?: number\r\n      edge?: 'start' | 'end'\r\n    } = {}\r\n  ): AncestorEntry {\r\n    if (Path.isPath(at) || Point.isPoint(at)) {\r\n      return this.getParent(at, options)\r\n    }\r\n\r\n    const path = this.getPath(at, options)\r\n    const ancestorPath = Path.equals(at.anchor.path, at.focus.path)\r\n      ? Path.parent(path)\r\n      : path\r\n\r\n    const ancestor = Node.get(this.value, ancestorPath) as Ancestor\r\n    return [ancestor, ancestorPath]\r\n  }\r\n\r\n  /**\r\n   * Get the point before a location.\r\n   */\r\n\r\n  getBefore(\r\n    this: Editor,\r\n    at: Location,\r\n    options: {\r\n      distance?: number\r\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\r\n    } = {}\r\n  ): Point | undefined {\r\n    const anchor = this.getStart([])\r\n    const focus = this.getPoint(at, { edge: 'start' })\r\n    const range = { anchor, focus }\r\n    const { distance = 1 } = options\r\n    let d = 0\r\n    let target\r\n\r\n    for (const p of this.positions({ ...options, at: range, reverse: true })) {\r\n      if (d > distance) {\r\n        break\r\n      }\r\n\r\n      if (d !== 0) {\r\n        target = p\r\n      }\r\n\r\n      d++\r\n    }\r\n\r\n    return target\r\n  }\r\n\r\n  /**\r\n   * Get the start and end points of a location.\r\n   */\r\n\r\n  getEdges(this: Editor, at: Location): [Point, Point] {\r\n    return [this.getStart(at), this.getEnd(at)]\r\n  }\r\n\r\n  /**\r\n   * Get the end point of a location.\r\n   */\r\n\r\n  getEnd(this: Editor, at: Location): Point {\r\n    return this.getPoint(at, { edge: 'end' })\r\n  }\r\n\r\n  /**\r\n   * Get the first node at a location.\r\n   */\r\n\r\n  getFirst(this: Editor, at: Location): NodeEntry {\r\n    const path = this.getPath(at, { edge: 'start' })\r\n    return this.getNode(path)\r\n  }\r\n\r\n  /**\r\n   * Get the fragment at a location.\r\n   */\r\n\r\n  getFragment(this: Editor, at: Location): Descendant[] {\r\n    const range = this.getRange(at)\r\n    const fragment = Node.fragment(this.value, range)\r\n    return fragment\r\n  }\r\n\r\n  /**\r\n   * Get the last node at a location.\r\n   */\r\n\r\n  getLast(this: Editor, at: Location): NodeEntry {\r\n    const path = this.getPath(at, { edge: 'end' })\r\n    return this.getNode(path)\r\n  }\r\n\r\n  /**\r\n   * Get the leaf text node at a location.\r\n   */\r\n\r\n  getLeaf(\r\n    this: Editor,\r\n    at: Location,\r\n    options: {\r\n      depth?: number\r\n      edge?: 'start' | 'end'\r\n    } = {}\r\n  ): TextEntry {\r\n    const path = this.getPath(at, options)\r\n    const node = Node.leaf(this.value, path)\r\n    return [node, path]\r\n  }\r\n\r\n  /**\r\n   * Get the first matching node in a single branch of the document.\r\n   */\r\n\r\n  getMatch(\r\n    this: Editor,\r\n    at: Location,\r\n    match: NodeMatch\r\n  ): NodeEntry | undefined {\r\n    const path = this.getPath(at)\r\n\r\n    for (const entry of this.levels({ at: path })) {\r\n      if (this.isNodeMatch(entry, match)) {\r\n        return entry\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */\r\n\r\n  getNext(this: Editor, at: Location, match: NodeMatch): NodeEntry | undefined {\r\n    const [, from] = this.getLast(at)\r\n    const [, to] = this.getLast([])\r\n    const span: Span = [from, to]\r\n    let i = 0\r\n\r\n    for (const entry of this.matches({ at: span, match })) {\r\n      if (i === 1) {\r\n        return entry\r\n      }\r\n\r\n      i++\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the node at a location.\r\n   */\r\n\r\n  getNode(\r\n    this: Editor,\r\n    at: Location,\r\n    options: {\r\n      depth?: number\r\n      edge?: 'start' | 'end'\r\n    } = {}\r\n  ): NodeEntry {\r\n    const path = this.getPath(at, options)\r\n    const node = Node.get(this.value, path)\r\n    return [node, path]\r\n  }\r\n\r\n  /**\r\n   * Get the parent node of a location.\r\n   */\r\n\r\n  getParent(\r\n    this: Editor,\r\n    at: Location,\r\n    options: {\r\n      depth?: number\r\n      edge?: 'start' | 'end'\r\n    } = {}\r\n  ): AncestorEntry {\r\n    const path = this.getPath(at, options)\r\n    const parentPath = Path.parent(path)\r\n    const entry = this.getNode(parentPath)\r\n    return entry as AncestorEntry\r\n  }\r\n\r\n  /**\r\n   * Get the path of a location.\r\n   */\r\n\r\n  getPath(\r\n    this: Editor,\r\n    at: Location,\r\n    options: {\r\n      depth?: number\r\n      edge?: 'start' | 'end'\r\n    } = {}\r\n  ): Path {\r\n    const { depth, edge } = options\r\n\r\n    if (Path.isPath(at)) {\r\n      if (edge === 'start') {\r\n        const [, firstPath] = Node.first(this.value, at)\r\n        at = firstPath\r\n      } else if (edge === 'end') {\r\n        const [, lastPath] = Node.last(this.value, at)\r\n        at = lastPath\r\n      }\r\n    }\r\n\r\n    if (Range.isRange(at)) {\r\n      if (edge === 'start') {\r\n        at = Range.start(at)\r\n      } else if (edge === 'end') {\r\n        at = Range.end(at)\r\n      } else {\r\n        at = Path.common(at.anchor.path, at.focus.path)\r\n      }\r\n    }\r\n\r\n    if (Point.isPoint(at)) {\r\n      at = at.path\r\n    }\r\n\r\n    if (depth != null) {\r\n      at = at.slice(0, depth)\r\n    }\r\n\r\n    return at\r\n  }\r\n\r\n  /**\r\n   * Get the start or end point of a location.\r\n   */\r\n\r\n  getPoint(\r\n    this: Editor,\r\n    at: Location,\r\n    options: {\r\n      edge?: 'start' | 'end'\r\n    } = {}\r\n  ): Point {\r\n    const { edge = 'start' } = options\r\n\r\n    if (Path.isPath(at)) {\r\n      let path\r\n\r\n      if (edge === 'end') {\r\n        const [, lastPath] = Node.last(this.value, at)\r\n        path = lastPath\r\n      } else {\r\n        const [, firstPath] = Node.first(this.value, at)\r\n        path = firstPath\r\n      }\r\n\r\n      const node = Node.get(this.value, path)\r\n\r\n      if (!Text.isText(node)) {\r\n        throw new Error(\r\n          `Cannot get the ${edge} point in the node at path [${at}] because it has no ${edge} text node.`\r\n        )\r\n      }\r\n\r\n      return { path, offset: edge === 'end' ? node.text.length : 0 }\r\n    }\r\n\r\n    if (Range.isRange(at)) {\r\n      const [start, end] = Range.edges(at)\r\n      return edge === 'start' ? start : end\r\n    }\r\n\r\n    return at\r\n  }\r\n\r\n  /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */\r\n\r\n  getPrevious(\r\n    this: Editor,\r\n    at: Location,\r\n    match: NodeMatch\r\n  ): NodeEntry | undefined {\r\n    const [, from] = this.getFirst(at)\r\n    const [, to] = this.getFirst([])\r\n    const span: Span = [from, to]\r\n    let i = 0\r\n\r\n    for (const entry of this.matches({ match, at: span, reverse: true })) {\r\n      if (i === 1) {\r\n        return entry\r\n      }\r\n\r\n      i++\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a range of a location.\r\n   */\r\n\r\n  getRange(this: Editor, at: Location, to?: Location): Range {\r\n    if (Range.isRange(at) && !to) {\r\n      return at\r\n    }\r\n\r\n    const start = this.getStart(at)\r\n    const end = this.getEnd(to || at)\r\n    return { anchor: start, focus: end }\r\n  }\r\n\r\n  /**\r\n   * Get the start point of a location.\r\n   */\r\n\r\n  getStart(this: Editor, at: Location): Point {\r\n    return this.getPoint(at, { edge: 'start' })\r\n  }\r\n\r\n  /**\r\n   * Get the text content of a location.\r\n   *\r\n   * Note: the text of void nodes is presumed to be an empty string, regardless\r\n   * of what their actual content is.\r\n   */\r\n\r\n  getText(this: Editor, at: Location): string {\r\n    const range = this.getRange(at)\r\n    const [start, end] = Range.edges(range)\r\n    let text = ''\r\n\r\n    for (const [node, path] of this.texts({ at: range })) {\r\n      let t = node.text\r\n\r\n      if (Path.equals(path, end.path)) {\r\n        t = t.slice(0, end.offset)\r\n      }\r\n\r\n      if (Path.equals(path, start.path)) {\r\n        t = t.slice(start.offset)\r\n      }\r\n\r\n      text += t\r\n    }\r\n\r\n    return text\r\n  }\r\n\r\n  /**\r\n   * Check if there is a node at a location.\r\n   */\r\n\r\n  hasNode(\r\n    this: Editor,\r\n    at: Location,\r\n    options: {\r\n      depth?: number\r\n      edge?: 'start' | 'end'\r\n    } = {}\r\n  ): boolean {\r\n    const path = this.getPath(at, options)\r\n    const exists = Node.has(this.value, path)\r\n    return exists\r\n  }\r\n\r\n  /**\r\n   * Check if a point the start point of a location.\r\n   */\r\n\r\n  isStart(this: Editor, point: Point, at: Location): boolean {\r\n    // PERF: If the offset isn't `0` we know it's not the start.\r\n    if (point.offset !== 0) {\r\n      return false\r\n    }\r\n\r\n    const start = this.getStart(at)\r\n    return Point.equals(point, start)\r\n  }\r\n\r\n  /**\r\n   * Check if a point is the end point of a location.\r\n   */\r\n\r\n  isEnd(this: Editor, point: Point, at: Location): boolean {\r\n    const end = this.getEnd(at)\r\n    return Point.equals(point, end)\r\n  }\r\n\r\n  /**\r\n   * Check if a point is an edge of a location.\r\n   */\r\n\r\n  isEdge(this: Editor, point: Point, at: Location): boolean {\r\n    return this.isStart(point, at) || this.isEnd(point, at)\r\n  }\r\n\r\n  /**\r\n   * Iterate through all of the levels at a location.\r\n   */\r\n\r\n  *levels(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Iterable<NodeEntry> {\r\n    const { at = this.value.selection, reverse = false } = options\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    const levels: NodeEntry[] = []\r\n    const path = this.getPath(at)\r\n\r\n    for (const [n, p] of Node.levels(this.value, path)) {\r\n      levels.push([n, p])\r\n\r\n      if (Element.isElement(n) && this.isVoid(n)) {\r\n        break\r\n      }\r\n    }\r\n\r\n    if (reverse) {\r\n      levels.reverse()\r\n    }\r\n\r\n    yield* levels\r\n  }\r\n\r\n  /**\r\n   * Iterate through all of the text nodes in the editor.\r\n   */\r\n\r\n  *marks(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location | Span\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Iterable<MarkEntry> {\r\n    const { at = this.value.selection } = options\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    const [from, to] = getSpan(this, at, options)\r\n\r\n    yield* Node.marks(this.value, {\r\n      ...options,\r\n      from,\r\n      to,\r\n      pass: ([n]) => Element.isElement(n) && this.isVoid(n),\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Iterate through all of the nodes that match.\r\n   */\r\n\r\n  *matches(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location | Span\r\n      match?: NodeMatch\r\n      reverse?: boolean\r\n    }\r\n  ): Iterable<NodeEntry> {\r\n    const { at = this.value.selection, reverse = false } = options\r\n    let { match } = options\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    if (match == null) {\r\n      if (Path.isPath(at)) {\r\n        const path = at\r\n        match = ([, p]) => Path.equals(p, path)\r\n      } else {\r\n        match = () => true\r\n      }\r\n    }\r\n\r\n    let prevPath: Path | undefined\r\n\r\n    for (const [n, p] of this.nodes({ at, reverse })) {\r\n      if (prevPath && Path.compare(p, prevPath) === 0) {\r\n        continue\r\n      }\r\n\r\n      if (this.isNodeMatch([n, p], match)) {\r\n        prevPath = p\r\n        yield [n, p]\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iterate through all of the nodes in the editor.\r\n   */\r\n\r\n  *nodes(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location | Span\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Iterable<NodeEntry> {\r\n    const { at = this.value.selection } = options\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    const [from, to] = getSpan(this, at, options)\r\n    const iterable = Node.nodes(this.value, {\r\n      ...options,\r\n      from,\r\n      to,\r\n      pass: ([n]) => Element.isElement(n) && this.isVoid(n),\r\n    })\r\n\r\n    for (const entry of iterable) {\r\n      yield entry\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iterate through all of the positions in the document where a `Point` can be\r\n   * placed.\r\n   *\r\n   * By default it will move forward by individual offsets at a time,  but you\r\n   * can pass the `unit: 'character'` option to moved forward one character, word,\r\n   * or line at at time.\r\n   *\r\n   * Note: void nodes are treated as a single point, and iteration will not\r\n   * happen inside their content.\r\n   */\r\n\r\n  *positions(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location\r\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Iterable<Point> {\r\n    const {\r\n      at = this.value.selection,\r\n      unit = 'offset',\r\n      reverse = false,\r\n    } = options\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    const range = this.getRange(at)\r\n    const [start, end] = Range.edges(range)\r\n    const first = reverse ? end : start\r\n    let string = ''\r\n    let available = 0\r\n    let offset = 0\r\n    let distance: number | null = null\r\n    let isNewBlock = false\r\n\r\n    const advance = () => {\r\n      if (distance == null) {\r\n        if (unit === 'character') {\r\n          distance = getCharacterDistance(string)\r\n        } else if (unit === 'word') {\r\n          distance = getWordDistance(string)\r\n        } else if (unit === 'line' || unit === 'block') {\r\n          distance = string.length\r\n        } else {\r\n          distance = 1\r\n        }\r\n\r\n        string = string.slice(distance)\r\n      }\r\n\r\n      // Add or substract the offset.\r\n      offset = reverse ? offset - distance : offset + distance\r\n      // Subtract the distance traveled from the available text.\r\n      available = available - distance!\r\n      // If the available had room to spare, reset the distance so that it will\r\n      // advance again next time. Otherwise, set it to the overflow amount.\r\n      distance = available >= 0 ? null : 0 - available\r\n    }\r\n\r\n    for (const [node, path] of this.nodes({ at, reverse })) {\r\n      if (Element.isElement(node)) {\r\n        // Void nodes are a special case, since we don't want to iterate over\r\n        // their content. We instead always just yield their first point.\r\n        if (this.isVoid(node)) {\r\n          yield this.getStart(path)\r\n          continue\r\n        }\r\n\r\n        if (this.isInline(node)) {\r\n          continue\r\n        }\r\n\r\n        if (this.hasInlines(node)) {\r\n          const e = Path.isAncestor(path, end.path) ? end : this.getEnd(path)\r\n          const s = Path.isAncestor(path, start.path)\r\n            ? start\r\n            : this.getStart(path)\r\n\r\n          const text = this.getText({ anchor: s, focus: e })\r\n          string = reverse ? reverseText(text) : text\r\n          isNewBlock = true\r\n        }\r\n      }\r\n\r\n      if (Text.isText(node)) {\r\n        const isFirst = Path.equals(path, first.path)\r\n        available = node.text.length\r\n        offset = reverse ? available : 0\r\n\r\n        if (isFirst) {\r\n          available = reverse ? first.offset : available - first.offset\r\n          offset = first.offset\r\n        }\r\n\r\n        if (isFirst || isNewBlock || unit === 'offset') {\r\n          yield { path, offset }\r\n        }\r\n\r\n        while (true) {\r\n          // If there's no more string, continue to the next block.\r\n          if (string === '') {\r\n            break\r\n          } else {\r\n            advance()\r\n          }\r\n\r\n          // If the available space hasn't overflow, we have another point to\r\n          // yield in the current text node.\r\n          if (available >= 0) {\r\n            yield { path, offset }\r\n          } else {\r\n            break\r\n          }\r\n        }\r\n\r\n        isNewBlock = false\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iterate through all of the text nodes in the editor.\r\n   */\r\n\r\n  *texts(\r\n    this: Editor,\r\n    options: {\r\n      at?: Location | Span\r\n      reverse?: boolean\r\n    } = {}\r\n  ): Iterable<TextEntry> {\r\n    const { at = this.value.selection } = options\r\n\r\n    if (!at) {\r\n      return\r\n    }\r\n\r\n    const [from, to] = getSpan(this, at, options)\r\n\r\n    yield* Node.texts(this.value, {\r\n      ...options,\r\n      from,\r\n      to,\r\n      pass: ([n]) => Element.isElement(n) && this.isVoid(n),\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * Get the from and to path span from a location.\r\n */\r\n\r\nconst getSpan = (\r\n  editor: Editor,\r\n  at: Location | Span,\r\n  options: {\r\n    reverse?: boolean\r\n  } = {}\r\n): Span => {\r\n  const { reverse = false } = options\r\n\r\n  if (Span.isSpan(at)) {\r\n    return at\r\n  }\r\n\r\n  const first = editor.getPath(at, { edge: 'start' })\r\n  const last = editor.getPath(at, { edge: 'end' })\r\n  const from = reverse ? last : first\r\n  const to = reverse ? first : last\r\n  return [from, to]\r\n}\r\n\r\nexport default LocationQueries\r\n","import {\r\n  Editor,\r\n  Element,\r\n  Node,\r\n  NodeEntry,\r\n  NodeMatch,\r\n  Path,\r\n  Text,\r\n  Value,\r\n} from '../..'\r\n\r\nclass NodeQueries {\r\n  /**\r\n   * Check if a node entry is a match.\r\n   */\r\n\r\n  isNodeMatch(this: Editor, entry: NodeEntry, match: NodeMatch | NodeMatch[]) {\r\n    const [node] = entry\r\n\r\n    // If match is an array, treat it as an OR condition.\r\n    if (Array.isArray(match)) {\r\n      for (const m of match) {\r\n        if (this.isNodeMatch(entry, m)) {\r\n          return true\r\n        }\r\n      }\r\n\r\n      return false\r\n    }\r\n\r\n    switch (match) {\r\n      case 'text':\r\n        return Text.isText(node)\r\n      case 'value':\r\n        return Value.isValue(node)\r\n      case 'element':\r\n        return Element.isElement(node)\r\n      case 'inline':\r\n        return (\r\n          (Element.isElement(node) && this.isInline(node)) || Text.isText(node)\r\n        )\r\n      case 'inline-element':\r\n        return Element.isElement(node) && this.isInline(node)\r\n      case 'block':\r\n        return (\r\n          Element.isElement(node) &&\r\n          !this.isInline(node) &&\r\n          this.hasInlines(node)\r\n        )\r\n      case 'void':\r\n        return Element.isElement(node) && this.isVoid(node)\r\n    }\r\n\r\n    if (typeof match === 'function') {\r\n      return match(entry)\r\n    } else {\r\n      return Node.matches(node, match)\r\n    }\r\n  }\r\n}\r\n\r\nexport default NodeQueries\r\n","import { Editor, Path, Range } from '../..'\r\n\r\nclass RangeQueries {\r\n  /**\r\n   * Convert a range into a non-hanging one.\r\n   */\r\n\r\n  unhangRange(this: Editor, range: Range): Range {\r\n    let [start, end] = Range.edges(range)\r\n\r\n    // PERF: exit early if we can guarantee that the range isn't hanging.\r\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\r\n      return range\r\n    }\r\n\r\n    const closestBlock = this.getMatch(end.path, 'block')\r\n    const blockPath = closestBlock ? closestBlock[1] : []\r\n    const first = this.getStart([])\r\n    const before = { anchor: first, focus: end }\r\n    let skip = true\r\n\r\n    for (const [node, path] of this.texts({ at: before, reverse: true })) {\r\n      if (skip) {\r\n        skip = false\r\n        continue\r\n      }\r\n\r\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\r\n        end = { path, offset: node.text.length }\r\n        break\r\n      }\r\n    }\r\n\r\n    return { anchor: start, focus: end }\r\n  }\r\n}\r\n\r\nexport default RangeQueries\r\n","import { produce } from 'immer'\r\n\r\nimport { Operation, Value } from '..'\r\nimport {\r\n  DIRTY_PATHS,\r\n  NORMALIZING,\r\n  FLUSHING,\r\n  PATH_REFS,\r\n  POINT_REFS,\r\n  RANGE_REFS,\r\n} from '../utils/state'\r\n\r\nimport AnnotationCommands from './commands/annotation'\r\nimport TextCommands from './commands/text'\r\nimport NodeCommands from './commands/node'\r\nimport MarkCommands from './commands/mark'\r\nimport SelectionCommands from './commands/selection'\r\nimport GeneralCommands from './commands/general'\r\nimport ElementQueries from './queries/element'\r\nimport GeneralQueries from './queries/general'\r\nimport LocationQueries from './queries/location'\r\nimport NodeQueries from './queries/node'\r\nimport RangeQueries from './queries/range'\r\n\r\n/**\r\n * The `Editor` class stores all the state of a Slate editor. It is extended by\r\n * plugins that wish to add their own methods that implement new behaviors.\r\n */\r\n\r\nexport class Editor {\r\n  onChange: (value: Value, operations: Operation[]) => void\r\n  operations: Operation[]\r\n  value: Value\r\n\r\n  constructor(\r\n    props: {\r\n      onChange?(value: Value, operations: Operation[]): void\r\n      readOnly?: boolean\r\n      value?: Value\r\n    } = {}\r\n  ) {\r\n    const {\r\n      onChange = () => {},\r\n      value = produce(\r\n        { children: [], selection: null, annotations: {} },\r\n        () => {}\r\n      ),\r\n    } = props\r\n\r\n    this.onChange = onChange\r\n    this.operations = []\r\n    this.value = value\r\n\r\n    DIRTY_PATHS.set(this, [])\r\n    FLUSHING.set(this, false)\r\n    NORMALIZING.set(this, true)\r\n    PATH_REFS.set(this, new Set())\r\n    POINT_REFS.set(this, new Set())\r\n    RANGE_REFS.set(this, new Set())\r\n  }\r\n}\r\n\r\nexport interface Editor\r\n  extends AnnotationCommands,\r\n    TextCommands,\r\n    NodeCommands,\r\n    MarkCommands,\r\n    SelectionCommands,\r\n    GeneralCommands,\r\n    ElementQueries,\r\n    GeneralQueries,\r\n    LocationQueries,\r\n    NodeQueries,\r\n    RangeQueries {}\r\n\r\nconst mixin = (Mixins: Array<new () => any>) => {\r\n  for (const Mixin of Mixins) {\r\n    for (const key of Object.getOwnPropertyNames(Mixin.prototype)) {\r\n      if (key !== 'constructor') {\r\n        Editor.prototype[key] = Mixin.prototype[key]\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmixin([\r\n  AnnotationCommands,\r\n  TextCommands,\r\n  NodeCommands,\r\n  MarkCommands,\r\n  SelectionCommands,\r\n  GeneralCommands,\r\n  ElementQueries,\r\n  GeneralQueries,\r\n  LocationQueries,\r\n  NodeQueries,\r\n  RangeQueries,\r\n])\r\n"],"names":["DIRTY_PATHS","WeakMap","NORMALIZING","FLUSHING","PATH_REFS","POINT_REFS","RANGE_REFS","PathRef","props","path","affinity","editor","current","pathRefs","get","add","op","Path","transform","unref","PointRef","point","pointRefs","Point","RangeRef","range","rangeRefs","Range","Element","value","isPlainObject","Node","isNodeList","children","Value","isValue","Array","isArray","length","isElement","element","key","Location","isPath","isPoint","isRange","Span","every","Mark","mark","marks","find","f","matches","isMark","undefined","require$$0","ancestors","descendants","elements","levels","nodes","texts","node","Text","isText","root","Error","options","p","n","ancestor","entry","index","JSON","stringify","c","predicate","reverse","another","common","slice","push","newRoot","produce","r","edges","start","end","iterable","pass","includes","parent","splice","equals","leaf","text","offset","annotations","selection","i","isNode","from","to","visited","Set","isBefore","isAfter","has","nextIndex","isAncestor","concat","newPath","next","previous","parentPath","map","join","Operation","isOperation","type","endsWith","annotation","position","target","properties","newProperties","inversePath","inverseNewPath","paths","av","bv","min","Math","as","bs","compare","al","bl","list","last","operation","endsBefore","onp","copy","result","anchor","focus","rest","s1","e1","s2","e2","isRangeList","isRangeMap","rs","re","ts","te","isAfterStart","isBeforeEnd","isCollapsed","isBackward","affinityAnchor","affinityFocus","isForward","existing","m","exists","points","v","before","after","prevPath","prev","truePath","newParent","newIndex","k","prevNode","nextPath","newNextPath","Object","assign","newNode","AnnotationCommands","apply","newProps","prevProps","keys","DeletingCommands","withoutNormalizing","unit","distance","at","hanging","furthestVoid","getMatch","voidPath","opts","getBefore","getStart","getAfter","getEnd","removeNodes","unhangRange","getAncestor","isSingleText","startVoid","endVoid","block","match","isVoid","isCommon","createPathRef","startRef","createPointRef","endRef","getLeaf","pathRef","isBlockAncestor","isInline","mergeNodes","select","fragment","pointRef","inlineElementMatch","inlinePath","isEnd","isStart","blockMatch","blockPath","isBlockStart","isBlockEnd","mergeStart","mergeEnd","first","firstPath","lastPath","matcher","starts","middles","ends","starting","hasBlocks","inlineMatch","isInlineStart","isInlineEnd","middleRef","splitNodes","insertNodes","NodeCommands","atMatch","matchPath","isAtEnd","getNode","moveNodes","prevMatch","getPrevious","commonPath","isPreviousSibling","isSibling","emptyAncestor","furthest","isDescendant","emptyRef","isEmpty","toRef","targets","child","shouldHaveInlines","isLast","isInlineOrText","newChild","depths","height","always","deleteRange","getPoint","beforeRef","highest","voidMatch","nudge","voidNode","afterPath","siblingHeight","afterRef","depth","highestPath","lowestPath","split","isEdge","getRange","intersection","liftNodes","rangeRef","createRangeRef","roots","rootPath","a","wrapperPath","wrapper","MarkCommands","splitLocation","set","getActiveMarks","removeMarks","addMarks","SelectionCommands","edge","setSelection","newPoint","oldProps","GeneralCommands","ref","dirtyPaths","oldDirtyPaths","newDirtyPaths","getDirtyPaths","operations","normalize","Promise","resolve","then","flush","onChange","force","allPaths","max","pop","normalizeNodes","fn","previousPath","oldAncestors","newAncestors","ElementQueries","some","GeneralQueries","SPACE","PUNCTUATION","CHAMELEON","SURROGATE_START","SURROGATE_END","isWordCharacter","char","remaining","test","charAt","getCharacterDistance","code","charCodeAt","isSurrogate","getWordDistance","started","l","LocationQueries","getSpan","union","d","positions","getParent","getPath","ancestorPath","isNodeMatch","getLast","span","getFirst","t","string","available","isNewBlock","advance","hasInlines","e","s","getText","reverseText","isFirst","isSpan","NodeQueries","RangeQueries","closestBlock","skip","Editor","mixin","Mixins","Mixin","getOwnPropertyNames","prototype","TextCommands"],"mappings":"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"}